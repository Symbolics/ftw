Home Contents Subscribe Next
Introduction to Windows API

This is Windows API tutorial. This tutorial will teach you the basics and more advanced topics of programming in Windows API with the C programming language. It does not cover MFC. (Microsoft Foundation Classes is a widely used C++ library for developing C++ applications on Windows.) This tutorial has been created and tested on Windows 7. The examples have been built using Pelles C compiler. If you plan to read this tutorial, you are advised to download and install this compiler. (It is a freeware.) If you want to use some other compiler make sure that is supports the C99 standard.


 
Windows API

The Windows API is the application programming interface that is used to create Windows applications. In order to create Windows applications, we must download the Windows SDK. (Formerly known as Platform SDK.) The SDK (Software Development Kit) contains header files, libraries, samples, documentation and tools that use the Windows API to develop applications. The Windows API is created for C and C++ programming languages. It is the most direct way to create Windows applications. (If we install Pelles C, the Windows SDK is already included.)

The Windows API can be divided into several areas:

Base services
Security
Graphics
User interface
Multimedia
Windows shell
Networking
The Base services provide access to the fundamental resources on Windows. These include file systems, devices, processes, threads, registry or error handling. The Security area provides functions, interfaces, objects and other programming elements for authentication, authorisation, cryptography and other security related tasks. The Graphics subsystem provides functionality for outputting graphical content to monitors, printers and other output devices. The User interface provides functionality to create windows and controls. The Multimedia component provides tools for working with video, sound and input devices. The functions of the Windows shell interface allow applications to access the functionality provided by the operating system shell. The Network services provide access to the network capabilities of the Windows OS.

Windows API is an abstract specification of the programming interface to the Windows operating system. It consists of declarations of functions, unions, structures, data types, macros, constants and other programming elements. Windows API is described mainly by the MSDN (Microsoft Developer Network) and resides in the Windows C headers. The official implementation of the Windows API functions is located in dynamic libraries (DLLs). For example kernel32.dll, user32.dll, gdi32.dll, or shell32.dll in the Windows system directory. There are third-party implementations of Windows API: most notably the Wine project and the ReactOS project.

Windows API is a dynamic entity. The number of functions continuously grows with every new version of Windows OS and new service packs. There are also some important differences between the server versions and desktop versions of the operating system. Some functions are not officially documented.

Pelles C

Pelles C is an excellent C compiler and integrated development environment (IDE) for the C programming language. It supports both 32-bit Windows (x86) and 64-bit Windows (x64). It implements both C99 and C11 standards. Pelles C has an integrated resource editor, bitmap, icon and cursor editor, and a hex-dump editor. It is developed by a Swedish developer Pelle Orinius. It comes with Windows SDK, so we can immediately start creating Windows applications without further installations.

Pelles C is a freeware. We can download Pelles C from the following link: Pelles C download.

No target architecture error

In order to create Windows API programs, we have to enable Microsoft extensions. They are not enabled by default; therefore, the compiler produces the following error message: fatal error #1014: #error: "No target architecture". To enable Microsoft extensions, we go to the project options and select the Compiler tab. In this tab we check the Enable Microsoft Extensions box.

MSDN

The MSDN (Microsoft Developer Network) is a central portal for Windows development. It is a huge collection of material related to development of Windows applications using Microsoft tools. (Third party software like Qt4 or Java Swing is not covered.) It is the most complete reference for the Windows API. The following two links are good entry points for the Windows API reference: the Desktop App Development Documentation and the Windows API list.

This chapter was an introduction to Windows API.




;; ---------------------------

Windows API main functions

In this part of the Windows API tutorial, we will talk about main functions.


 
The main function prototypes

The main() function is an entry point to a C program. However, it is not the first program to run. When the entry point is main(), the program execution actually begins in a function called mainCRTStartup(). This function is located in the C runtime library. It initialises things like the memory manager, file I/O support, and the argv parameter. After that, the mainCRTStartup() function will call the main() function.

int main(void);
int main(int argc, char **argv);
int main(int argc, char *argv[]);
These are the function prototypes for the main() function for the classic console program.

classic_console.c
#include <stdio.h>

int main(void) {

    puts("This is a classic C program.");

    return 0;
}
The above source code presents an example of a classic console C program.

C:\Users\Jano\Documents\Pelles C Projects\ClassicConsole>ClassicConsole.exe
This is a classic C program.
This is the output of the ClassicConsole.exe program.

The wmain function prototypes

The previous main function prototypes could receive only ASCII characters. If we want a program that could receive wide characters from the command line, we will use the wmain() function prototypes.

int wmain(void);
int wmain(int argc, wchar_t **argv);
int wmain(int argc, wchar_t *argv[]);
The above wmain() function prototypes receive wchar_t characters on the command line. When we use these prototypes, the execution begins in a function called wmainCRTStartup() which will later call the wmain() function.

win_console.c
#include <windows.h>
#include <wchar.h>

int wmain(int argc, wchar_t **argv) {

    PDWORD cChars = NULL;
    HANDLE std = GetStdHandle(STD_OUTPUT_HANDLE);   
    
    if (std == INVALID_HANDLE_VALUE) {
        wprintf(L"Cannot retrieve standard output handle\n (%d)", 
            GetLastError());
    }
 
    if (argv[1]) {
    
        WriteConsoleW(std, argv[1], wcslen(argv[1]), cChars, NULL);
    }
    
    CloseHandle(std);
 
    return 0;
}
We have a wmain() function which can receive wide characters. The example prints the first argument of the console program. To insert command line arguments in Pelles C, we go to Project options and select the General tab. There is an edit box called Command line arguments.

int wmain(int argc, wchar_t **argv) {
The wchar_t type of the second parameter of the wmain() function tells us that the program input is in wide characters.

HANDLE std = GetStdHandle(STD_OUTPUT_HANDLE);    
The GetStdHandle() function returns a handle to the standard output.

if (std == INVALID_HANDLE_VALUE) {
    wprintf(L"Cannot retrieve standard output handle\n (%d)", 
        GetLastError());
} 
In case of an error, we receive the INVALID_HANDLE_VALUE return code. For this situation we print an error message. The GetLastError() function retrieves last error code value.

WriteConsoleW(std, argv[1], wcslen(argv[1]), cChars, NULL);
We use the WriteConsoleW() function to write to the console in wide characters.

CloseHandle(std);
The CloseHandle() function closes the opened handle to the standard output.

C:\Users\Jano\Documents\Pelles C Projects\WindowsConsole>WindowsConsole.exe компилятор
компилятор
We pass a Russian word (compiler) as a parameter to our program. The program simply prints the parameter back to the console. Note that in order to see correct characters, we need to change the default font of the console to Lucida Console. We need a true type font to display wide characters correctly.

The _tmain function prototypes

The _tmain() function is a Microsoft extension. It enables programmers to easily create both ANSI and UNICODE builds of their programs. It is a C macro that translates to wmain() or main() functions, depending whether the _UNICODE constant is defined or not. It was common in the past to create both ANSI and UNICODE builds. Nowadays, many programmers recommend to create only Unicode programs. This is also what we will do in this tutorial. We will create mostly Unicode programs.

int _tmain(void);
int _tmain(int argc, TCHAR **argv);
int _tmain(int argc, TCHAR *argv[]);
These are the _tmain function prototypes. The TCHAR macro translates either to char or to wchar_t. It is controlled by the UNICODE constant.

tmain_ex.c
#define _UNICODE
#define UNICODE

#include <windows.h>
#include <tchar.h>

int _tmain(int argc, TCHAR *argv[]) {

    PDWORD cChars = NULL;
    HANDLE std = GetStdHandle(STD_OUTPUT_HANDLE);

    if (std == INVALID_HANDLE_VALUE) {
        _tprintf(L"Cannot retrieve standard output handle\n (%d)", 
            GetLastError());
    }  
        
    if (argv[1]) {
    
        WriteConsole(std, argv[1], _tcslen(argv[1]), cChars, NULL);
    }
    
    CloseHandle(std);

    return 0;
}
The example prints its first argument if available.

#define _UNICODE
#define UNICODE
Here we define two constants. These definitions mean that we are going to build a Unicode program. They translate C macros in C runtime and Windows header files. The _UNICODE constant translates macros in the C runtime. (These macros start with an underscore.) The UNICODE constant translates macros in the Windows header files.

#include <windows.h>
We include the definition of the TCHAR macro. The macro is affected by the UNICODE constant.

#include <tchar.h>
We must include this header file for the _tmain and _tcslen macros. They are translated depending on the _UNICODE constant.

int _tmain(int argc, TCHAR *argv[]) {
The _tmain() function translates in our case to wmain() and the TCHAR macro to wchar_t.

WriteConsole(std, argv[1], _tcslen(argv[1]), cChars, NULL);
The WriteConsole() macro is transleted to the WriteConsoleW() function. The WriteConsoleW() writes output to the console. The _tcslen macro is translated to wcslen() function; it returns the lenght of the wide string.

C:\Users\Jano\Documents\Pelles C Projects\TMainEx>TMainEx.exe "операционная система"
операционная система
The program takes another Russian word (operating system) as a parameter and prints it to the console.

The WinMain function prototypes

So far we had console main functions. For graphical user interface development, we use one of the WinMain function prototypes.

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    PWSTR pCmdLine, int nCmdShow);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, int nCmdShow);
int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    LPTSTR lpCmdLine, int nCmdShow);
These three function prototypes are used for entry points for Windows GUI applications. The wWinMain() function's pCmdLine parameter contains the command-line arguments as a Unicode string. The WinMain() function's pCmdLine parameter contains the command-line arguments as an ANSI string. The _tWinMain is a C macro that translates to other two function prototypes, depending whether the _UNICODE constant is defined.

When the entry point is WinMain(), the execution of the program begins in WinMainCRTStartup(). In case of wWinMain(), the execution begins in wWinMainCRTStartup().

winmain_ex.c
#include <windows.h>

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
               PWSTR szCmdLine, int CmdShow) {
               
    MessageBoxW(NULL, szCmdLine, L"Title", MB_OK);

    return 0;
}
This code shows a small message box on the screen. It displays the first command line argument.

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
               PWSTR szCmdLine, int CmdShow)
The third parameter of the wWinMain() function is a PWSTR (pointer to wide string). It accepts wide characters.

A message box
Figure: A message box
In this part of the Windows API tutorial, we have mentioned main functions.

;; ------------------------------

System functions in Windows API

In this part of the Windows API tutorial, we cover system functions. System functions receive information about the system and communicate with the system in various ways.


 
Screen size

The GetSystemMetrics() function retrieves various system metrics and system configuration settings.

screen_size.c
#include <windows.h>
#include <wchar.h>

#pragma comment(lib, "user32.lib")

int wmain(void) {

    int x = GetSystemMetrics(SM_CXSCREEN);
    int y = GetSystemMetrics(SM_CYSCREEN);

    wprintf(L"The screen size is: %dx%d\n", x, y);
    
    return 0;
}
The code example prints the screen size to the console.

#pragma comment(lib, "user32.lib")
The program needs the user32.lib library to compile.

int x = GetSystemMetrics(SM_CXSCREEN);
int y = GetSystemMetrics(SM_CYSCREEN);
We determine the screen resolution with the GetSystemMetrics().

C:\Users\Jano\Documents\Pelles C Projects\system\ScreenSize>ScreenSize.exe
The screen size is: 1280x800
The screen size is 1280x800.

Locking workstation

The LockWorkStation() locks the workstation's display.

lock_workstation.c
#include <windows.h>
#include <wchar.h>

#pragma comment(lib, "user32.lib")

int wmain(void) { 

    int r = LockWorkStation();

    if( r == 0 ) {
    
        wprintf(L"LockWorkStation() failed %d\n", GetLastError());
        return 1;
    }

    return 0;
}
The program needs the user32.lib to compile.

Computer name

The GetComputerNameEx() function retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup.

computer_name.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    wchar_t computerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = sizeof(computerName) / sizeof(computerName[0]);

    int r = GetComputerNameW(computerName, &size);

    if (r == 0) {
        wprintf(L"Failed to get computer name %ld", GetLastError());
        return 1;
    }

    wprintf(L"Computer name: %ls\n", computerName);

    return 0;
}
The example prints the computer name to the console.

wchar_t computerName[MAX_COMPUTERNAME_LENGTH + 1];
The MAX_COMPUTERNAME_LENGTH constant determines the maximum length of the computer name.

int r = GetComputerNameW(computerName, &size);
We get the name of the computer with the GetComputerNameW() function. The name is stored into the computerName array.

C:\Users\Jano\Documents\Pelles C Projects\system\ComputerName>ComputerName.exe
Computer name: ANDROMEDA
We run the code example.

Username

The GetUserNameW() function returns the user name.

username.c
#include <windows.h>
#include <Lmcons.h>
#include <wchar.h>

int wmain(void) {

    wchar_t username[UNLEN+1];
    DWORD len = sizeof(username) / sizeof(wchar_t);

    int r = GetUserNameW(username, &len);

    if (r == 0) {
        wprintf(L"Failed to get username %ld", GetLastError());
        return 1;
    }
  
    wprintf(L"User name: %ls\n", username);

    return 0;
}
The example prints the username to the console.

#include <Lmcons.h>
The Lmcons.h file has the definition of the ULEN constant.

wchar_t username[UNLEN+1];
The ULEN constant defines the maximum length of the username.

int r = GetUserNameW(username, &len);
The GetUserNameW() function retrieves the username and stores it into the username array.

C:\Users\Jano\Documents\Pelles C Projects\system\Username>username.exe
User name: Jano
This is a sample output of the username.exe program.

Current directory

Current directory is a directory in which the user is located or it is working it. In Windows API, the SetCurrentDirectoryW() changes the current directory and the GetCurrentDirectoryW() retrieves the current directory.

current_directory.c
#include <windows.h>
#include <wchar.h>

#define BUFSIZE MAX_PATH

int wmain(int argc, wchar_t **argv) {

    wchar_t buf[BUFSIZE];
    
    if(argc != 2) {

        wprintf(L"Usage: %ls <dir>\n", argv[0]);
        return 1;
    }

    DWORD r = SetCurrentDirectoryW(argv[1]);

    if (r == 0) {

        wprintf(L"SetCurrentDirectoryW() failed (%ld)\n", GetLastError());
        return 1;
    }

    r = GetCurrentDirectoryW(BUFSIZE, buf);

    if (r == 0) {

        wprintf(L"GetCurrentDirectoryW() failed (%ld)\n", GetLastError());
        return 1;
    }

    if (r > BUFSIZE) {

        wprintf(L"Buffer too small; needs %d characters\n", r);
        return 1;
    }

    wprintf(L"Current directory is: %ls\n", buf);

    return 0;
}
In the code example, we change and print the current working directory. The program receives one command line argument—the directory to change into.

#define BUFSIZE MAX_PATH
We use the MAX_PATH constant, which defines the maximum length of a system path.

if(argc != 2) {

    wprintf(L"Usage: %ls <dir>\n", argv[0]);
    return 1;
}
An error message is printed if we do not pass an argument to the program.

DWORD r = SetCurrentDirectoryW(argv[1]);
We use the SetCurrentDirectoryW() to change to the directory, which is passed as an argument.

r = GetCurrentDirectoryW(BUFSIZE, buf);
We get the current working directory with the GetCurrentDirectoryW() function call.

if (r > BUFSIZE) {

    wprintf(L"Buffer too small; needs %d characters\n", r);
    return 1;
}
If the returned value is bigger than BUFSIZE, the buffer was too small.

Windows version

The Version Helper functions can be used to determine the current OS version.

windows_version.c
#include <windows.h>
#include <wchar.h>
#include <VersionHelpers.h>

int wmain(void) {

    //if (IsWindows10OrGreater()) {
        
    //    wprintf(L"This is Windows 10+");
    // }
    if (IsWindows8Point1OrGreater()) {
        wprintf(L"This is Windows 8.1+\n");
    } else if (IsWindows8OrGreater()) {
        wprintf(L"This is Windows 8\n");
    } else if (IsWindows7OrGreater ()) {
        wprintf(L"This is Windows 7\n");
    } else if (IsWindowsVistaOrGreater ()) {
        wprintf(L"This is Windows Vista\n");
    } else if (IsWindowsXPOrGreater()) {
        wprintf(L"This is Windows XP\n");
    }

    return 0;
}
We use the Version Helper functions to determine the OS version.

#include <VersionHelpers.h>
The helper functions are declared in the VersionHelpers.h file.

//if (IsWindows10OrGreater()) {
    
//    wprintf(L"This is Windows 10+");
// }
At the time of the writing, Pelles C did not have the IsWindows10OrGreater() defined in its SDK.

if (IsWindows8Point1OrGreater()) {
    wprintf(L"This is Windows 8.1+\n");
} 
The IsWindows8Point1OrGreater() returns true if the current version is Windows 8.1 or greater.

C:\Users\Jano\Documents\Pelles C Projects\system\WindowsVersion>WindowsVersion.exe
This is Windows 7
This is a sample output of the program.

Memory

The GlobalMemoryStatusEx() retrieves information about the system's current usage of both physical and virtual memory.

memory.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    MEMORYSTATUSEX mem = {0};

    mem.dwLength = sizeof(mem);

    int r = GlobalMemoryStatusEx(&mem);

    if (r == 0) {
        wprintf(L"Failed to memory status %ld", GetLastError());
        return 1;
    }

    wprintf(L"Memory in use: %ld percent\n", mem.dwMemoryLoad);
    wprintf(L"Total physical memory: %lld\n", mem.ullTotalPhys);
    wprintf(L"Free physical memory: %lld\n", mem.ullAvailPhys);
    wprintf(L"Total virtual memory: %lld\n", mem.ullTotalVirtual);
    wprintf(L"Free virtual memory: %lld\n", mem.ullAvailVirtual);
    
    return 0;
}
The program prints statistics about memory usage to the console.

MEMORYSTATUSEX mem = {0};
The GlobalMemoryStatusEx() function stores information about memory status in the MEMORYSTATUSEX structure.

int r = GlobalMemoryStatusEx(&mem);
The GlobalMemoryStatusEx() function is executed; the information is stored in the structure.

wprintf(L"Memory in use: %ld percent\n", mem.dwMemoryLoad);
The dwMemoryLoad member specifies the approximate percentage of physical memory in use.

wprintf(L"Total physical memory: %lld\n", mem.ullTotalPhys);
The ullTotalPhys member specifies the actual physical memory in bytes.

wprintf(L"Free physical memory: %lld\n", mem.ullAvailPhys);
The ullTotalPhys member specifies the amount of physical memory currently available in bytes.

wprintf(L"Total virtual memory: %lld\n", mem.ullTotalVirtual);
The ullTotalVirtual member specifies the amount of the total virtual memory in bytes.

wprintf(L"Free virtual memory: %lld\n", mem.ullAvailVirtual);            
The ullAvailVirtual member specifies the amount of available virtual memory in bytes.

C:\Users\Jano\Documents\Pelles C Projects\system\Memory>Memory.exe
Memory in use: 47 percent
Total physical memory: 4226072576
Free physical memory: 2229788672
Total virtual memory: 8796092891136
Free virtual memory: 8796052586496
This is a sample output of the program.

Known Folders

Since Windows Vista, a new system is used for identifying important directories in Windows. It is known as Known Folders. Known folders uses a set of GUID (Globally unique identifier) values for referencing important folders.

The SHGetKnownFolderPath() function retrieves the full path of a known folder identified by the folder's id.

documents_dir.c
#include <windows.h>
#include <initguid.h>
#include <KnownFolders.h>
#include <ShlObj.h>
#include <wchar.h>

int wmain(void) {

    PWSTR path = NULL;
    
    HRESULT hr = SHGetKnownFolderPath(&FOLDERID_Documents, 0, NULL, &path);

    if (SUCCEEDED(hr)) {
        wprintf(L"%ls\n", path);
    }

    CoTaskMemFree(path);

    return 0;
}
The example determines the full path to the user's Documents directory. We need to add shell32.lib and ole32.lib to the project libraries.

#include <initguid.h>
Due to some internal API issues, we need to include the initguid.h file; otherwise, the example does not compile. It fails with the Unresolved external symbol 'FOLDERID_Documents' error.

HRESULT hr = SHGetKnownFolderPath(&FOLDERID_Documents, 0, NULL, &path);
The SHGetKnownFolderPath() is used to determine the path to the Documents directory.

if (SUCCEEDED(hr)) {
    wprintf(L"%ls\n", path);
}
The SUCCEEDED macro can be used to determine whether the function call succeeded.

CoTaskMemFree(path);
At the end, it is necessary to free the allocated memory with the CoTaskMemFree() function.

C:\Users\Jano\Documents\Pelles C Projects\system\DocumentsDir>DocumentsDir.exe
C:\Users\Jano\Documents
This is a sample output of the DocumentsDir.exe program.

Drive names

The GetLogicalDriveStringsW() function fills a buffer with strings that specify valid drives in the system.

get_drives.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    wchar_t LogicalDrives[MAX_PATH] = {0};
    DWORD r = GetLogicalDriveStringsW(MAX_PATH, LogicalDrives);
    
    if (r == 0) {
        wprintf(L"Failed to get drive names %ld", GetLastError());
        return 1;
    }

    if (r > 0 && r <= MAX_PATH) {
    
        wchar_t *SingleDrive = LogicalDrives;
        
        while(*SingleDrive) {
            wprintf(L"%ls\n", SingleDrive);

            SingleDrive += wcslen(SingleDrive) + 1;
        }
    }

    return 0;
}
The example prints valid drives in the system.

wchar_t LogicalDrives[MAX_PATH] = {0};
A drive name is a path type, so a MAX_PATH constant is relevant for its maximum length. The LogicalDrives is an array of strings which serves as a buffer for the GetLogicalDriveStringsW() function.

DWORD r = GetLogicalDriveStringsW(MAX_PATH, LogicalDrives);
The GetLogicalDriveStringsW() is called. The buffer is filled with null-terminated strings, which represent device names. The first parameter of the function is the maximum size of the specified buffer. The buffer is the second parameter.

wchar_t *SingleDrive = LogicalDrives;

while(*SingleDrive) {
    wprintf(L"%ls\n", SingleDrive);

    SingleDrive += wcslen(SingleDrive) + 1;
}
We go through the array of device names and print them to the console.

C:\Users\Jano\Documents\Pelles C Projects\system\GetDrives>GetDrives.exe
C:\
D:\
There are two drives on the system: C:\ and D:\.

Free space

The GetDiskFreeSpaceExW() retrieves information about the amount of space available on a disk volume. The function gives three pieces of information: the total amount of space, the free amount of space, and the free space available to the user that is associated with the calling thread.

free_disk_space.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    unsigned __int64 freeCall,
                     total,
                     free;

    int r = GetDiskFreeSpaceExW(L"C:\\", (PULARGE_INTEGER) &freeCall,
        (PULARGE_INTEGER) &total, (PULARGE_INTEGER) &free);

    if (r == 0) {

        wprintf(L"Failed to get free disk space %ld", GetLastError());
        return 1;
    }	

    wprintf(L"Available space to caller: %I64u MB\n", freeCall / (1024*1024));
    wprintf(L"Total space: %I64u MB\n", total / (1024*1024));
    wprintf(L"Free space on drive: %I64u MB\n", free / (1024*1024));
    
    return 0;
}
The example examines disk space on the C:\ drive.

unsigned __int64 freeCall,
                 total,
                 free;
The amounts are expressed in bytes; these can be very large numbers. The unsigned __int64 type is used, which is a positive 64-bit integer capable of storing very large values.

int r = GetDiskFreeSpaceExW(L"C:\\", (PULARGE_INTEGER) &freeCall,
    (PULARGE_INTEGER) &total, (PULARGE_INTEGER) &free);
The GetDiskFreeSpaceExW() is called.

wprintf(L"Available space to caller: %I64u MB\n", freeCall / (1024*1024));
wprintf(L"Total space: %I64u MB\n", total / (1024*1024));
wprintf(L"Free space on drive: %I64u MB\n", free / (1024*1024));
The three amounts are printed to the console with the wprintf() function. The values are expressed in MB.

C:\Users\Jano\Documents\Pelles C Projects\system\FreeDiskSpace>FreeDiskSpace.exe
Available space to caller: 20377 MB
Total space: 69999 MB
Free space on drive: 20377 MB
This is a sample output of the FreeDiskSpace.exe program.

CPU speed

The CPU speed can be determined by examining a registry value. The value is written to registry during installation. We need to query the HARDWARE\DESCRIPTION\System\CentralProcessor\0 key.

cpu_speed.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    DWORD BufSize = MAX_PATH;
    DWORD mhz = MAX_PATH;
    HKEY key;

    long r = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
        L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &key);

    if (r != ERROR_SUCCESS) {

        wprintf(L"RegOpenKeyExW() failed %ld", GetLastError());
        return 1;
    }

    r = RegQueryValueExW(key, L"~MHz", NULL, NULL, (LPBYTE) &mhz, &BufSize);

    if (r != ERROR_SUCCESS) {

        wprintf(L"RegQueryValueExW() failed %ld", GetLastError());
        return 1;
    }

    wprintf(L"CPU speed: %lu MHz\n", mhz);

    r = RegCloseKey(key);

    if (r != ERROR_SUCCESS) {

        wprintf(L"Failed to close registry handle %ld", GetLastError());
        return 1;
    }
    
    return 0;
}
The example determines the CPU speed.

long r = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
    L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &key);
The RegOpenKeyExW() function is used to open the provided registry key.

r = RegQueryValueExW(key, L"~MHz", NULL, NULL, (LPBYTE) &mhz, &BufSize);
The value is read with the RegQueryValueExW() function.

r = RegCloseKey(key);
The RegCloseKey() closes the registry handle.

C:\Users\Jano\Documents\Pelles C Projects\system\CpuSpeed>CpuSpeed.exe
CPU speed: 2394 MHz
This is a sample output of the CpuSpeed.exe program.

In this part of the Windows API tutorial, we have worked with several system functions.

;; --------------------------------

Strings in Windows API

In C language there is no string data type. A string literal in a program is an array of characters. Whenever we say string we mean an array of characters.


 
We have five sets of functions for working with strings; both in C runtime library (CRT) and in Windows API:

ANSI C standard functions
Security enhanced CRT functions
Windows API kernel and user functions
Windows API Shell Lightweight Utility functions
Windows API StrSafe functions
It is recommended to prefer either security enhanced standard functions or Windows API safe functions.

ANSI C string functions

The C Run-Time (CRT) library functions have some small overhead since they call Windows API functions underneath. These functions provide portability but have some limitations. When not used properly, they can cause security risks.

These functions do not return an error value when they fail.

ansic_functions.c
#include <windows.h>
#include <wchar.h>

#define STR_EQUAL 0

int wmain(void) {

    wchar_t str1[] = L"There are 15 pines";

    wprintf(L"The length of the string is %lld characters\n", wcslen(str1));

    wchar_t buf[20];
    wcscpy(buf, L"Wuthering");
    wcscat(buf, L" heights\n");
    wprintf(buf);

    if (wcscmp(L"rain", L"rainy")== STR_EQUAL) {

        wprintf(L"rain and rainy are equal strings\n");
    } else {

        wprintf(L"rain and rainy are not equal strings\n");
    } 

    return 0;
}
In the example we present a few string functions from the CRT library.

wprintf(L"The length of the string is %lld characters\n", wcslen(str1));
The wcslen() returns the number of wide-characters in the string.

wcscpy(buf, L"Wuthering");
The wcscpy() copies a string to a string buffer.

wcscat(buf, L" heights\n");
The wcscat() function appends a string to a string buffer.

if (wcscmp(L"rain", L"rainy")== STR_EQUAL) {

    wprintf(L"rain and rainy are equal strings\n");
} else {

    wprintf(L"rain and rainy are not equal strings\n");
} 
The wcscmp() compares two string.

C:\Users\Jano\Documents\Pelles C Projects\strings\ANSICFunctions>ANSICFunctions.exe
The length of the string is 18 characters
Wuthering heights
rain and rainy are not equal strings
This is the output of the example.

Security enhanced CRT functions

Security CRT functions add additional security to the CRT functions. (They are not standard functions but an MS extension.) These functions validate parameters, take size buffers, check that strings are NULL terminated, and provide enhanced error reporting.

Security CRT functions have an _s suffix.

security_enhanced.c
#include <windows.h>
#include <wchar.h>

#define BUF_LEN 25

int wmain(void) {

    wchar_t str1[] = L"There are 15 pines";

    const int MAX_CHARS = 50;
    size_t count = wcsnlen_s(str1, MAX_CHARS); 

    wprintf(L"The length of the string is %ld characters\n", count);

    wchar_t buf[BUF_LEN] = {0};

    int r = wcscpy_s(buf, BUF_LEN, L"Wuthering");

    if (r != 0) {

        wprintf(L"wcscpy_s() failed %ld", r);
    }

    r = wcscat_s(buf, BUF_LEN, L" heights\n");

    if (r != 0) {

        wcscat_s(L"wcscat_s() failed %ld", r);
    }

    wprintf_s(buf);

    return 0;
}
In the example, we present four functions: wcsnlen_s(), wcscpy_s(), wcscat_s(), and wprintf_s().

const int MAX_CHARS = 50;
size_t count = wcsnlen_s(str1, MAX_CHARS);
The wcsnlen_s() computes the lenght of a wide string. The function only checks the first MAX_CHARS characters.

int r = wcscpy_s(buf, BUF_LEN, L"Wuthering");
With the wcscpy_s() function, we copy the L"Wuthering" string into the buffer. The function takes the maximum number of characters in the buffer and it returns an error code if it fails. The function returns 0 on success.

r = wcscat_s(buf, BUF_LEN, L" heights\n");
The wcscat_s() is a secure extension of the wcscat() function.

wprintf_s(buf);
There is even a security enhanced wprintf() function; it has some runtime constraints.

C:\Users\Jano\Documents\Pelles C Projects\strings\SecurityEnhanced>SecurityEnhanced.exe
The length of the string is 18 characters
Wuthering heights
This is the output of the SecurityEnhanced.exe example.

Windows API kernel and user string functions

These functions are specific to Windows OS; they are available in User32.lib and Kernel32.lib. They are lighter than their CRT counterparts.

Kernel string functions have their roots in the development of the Windows kernel. They are prefixed with the l letter.

The string length

One of the most common requirements is to figure out the length of the string. The lstrlen() function returns the length of the specified string in characters. It does not count the terminating null character.

int WINAPI lstrlenA(LPCSTR lpString);
int WINAPI lstrlenW(LPCWSTR lpString);
The ANSI and the UNICODE functions take the string as a parameter and return the number of characters in the string.

winapi_string_lenght.c
#include <windows.h>
#include <wchar.h>

int wmain(void)  {

    char *name = "Jane";
    wchar_t *town = L"Bratislava";

    wprintf(L"The length of the name string is %d\n", lstrlenA(name));
    wprintf(L"The town string length is %d\n", lstrlenW(town));

    return 0;
}
We compute the length of two strings. The lstrlen() function is in fact a macro to either lstrlenA() or lstrlenW(). The first is used for ANSI strings, the second for wide strings.

wprintf(L"The town string length is %d\n", lstrlenW(town));
We print the length of the L"Bratislava" string using the lstrlenW() function.

C:\Users\Jano\Documents\Pelles C Projects\strings\WinapiStringLength>WinapiStringLength.exe
The length of the name string is 4
The town string length is 10
This is the output of the WinapiStringLength.exe program.

Concatenating strings

The lstrcatW() function appends one string to another string.

LPWSTR WINAPI lstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
The first parameter is the buffer which should contain both strings. It must be large enough to contain both of them, including the NULL terminating character. The return value is a pointer to the buffer.

winapi_string_concat.c
#include <windows.h>
#include <wchar.h>

int main(void) {

    wchar_t *s1 = L"ZetCode, ";
    wchar_t *s2 = L"tutorials ";
    wchar_t *s3 = L"for ";
    wchar_t *s4 = L"programmers.\n";

    int len = lstrlenW(s1) + lstrlenW(s2) 
        + lstrlenW(s3) + lstrlenW(s4);
    wchar_t buf[len+1];
  
    lstrcpyW(buf, s1);
    lstrcatW(buf, s2);
    lstrcatW(buf, s3);
    lstrcatW(buf, s4);

    wprintf(buf);    

    return 0;
}
In the example, we concatenate four strings.

wchar_t *s1 = L"ZetCode, ";
wchar_t *s2 = L"tutorials ";
wchar_t *s3 = L"for ";
wchar_t *s4 = L"programmers.\n";
These are the strings that we are going to concatenate.

int len = lstrlenW(s1) + lstrlenW(s2) 
    + lstrlenW(s3) + lstrlenW(s4);
We compute the length of the four strings using the lstrlenW() function.

wchar_t buf[len+1];
We create a buffer to hold the final string. Note that we add 1 to include the NULL character.

lstrcpyW(buf, s1);
We copy the first string to the buffer using the lstrcpyW() function.

lstrcatW(buf, s2);
lstrcatW(buf, s3);
lstrcatW(buf, s4);
We append the remaining strings with the lstrcatW() function.

C:\Users\Jano\Documents\Pelles C Projects\strings\WinapiStringConcat>WinapiStringConcat.exe
ZetCode, tutorials for programmers.
This is the output of the WinapiStringConcat.exe program.

Converting characters

We have two methods for converting characters to uppercase or to lowercase. The CharLowerW() function converts a character string or a single character to lowercase. The CharUpperW() function converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters in place. In other words, they are modified.

LPWSTR WINAPI CharLowerW(LPWSTR lpsz);
LPWSTR WINAPI CharUpperW(LPWSTR lpsz);
The functions modify the strings in place and return a pointer to the modified string.

winapi_string_case.c
#include <windows.h>
#include <wchar.h>

#pragma comment(lib, "User32.lib")

int wmain(void) {

    wchar_t str[] = L"Europa";

    CharLowerW(str);
    wprintf(L"%ls\n", str);

    CharUpperW(str);
    wprintf(L"%ls\n", str);    

    return 0;
}
We have one string which we convert to lowercase and uppercase.

CharLowerW(str);
wprintf(L"%ls\n", str);
We convert the str string to lowercase with the CharLowerW() method. The string is modified in place.

C:\winapi\examples2\strings\UpperLower>UpperLower.exe
europa
EUROPA
This is the output of the UpperLower.exe program.

Comparing strings

The lstrcmpW() function compares two strings. It returns 0 if the strings are equal. The comparison is case sensitive. This means that "Cup" and "cup" are two different strings. The lstrcmpiW() yields case insensitive string comparison. For this function, "Cup" and "cup" are equal.

int WINAPI lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
int WINAPI lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
The functions take two strings as parameters. The return value indicates the equality of the strings. 0 value is returned for equal strings.

winapi_string_compare.c
#include <windows.h>
#include <wchar.h>

#define STR_EQUAL 0

int wmain(void) {

    wchar_t *s1 = L"Strong";
    wchar_t *s2 = L"strong";
  
    if (lstrcmpW(s1, s2) == STR_EQUAL) {
  
        wprintf(L"%ls and %ls are equal\n", s1, s2);
    } else {
  
        wprintf(L"%ls and %ls are not equal\n", s1, s2);
    }

    wprintf(L"When applying case insensitive comparison:\n");
    
    if (lstrcmpiW(s1, s2) == STR_EQUAL) {
  
        wprintf(L"%ls and %ls are equal\n", s1, s2);
    } else {
  
        wprintf(L"%ls and %ls are not equal\n", s1, s2);
    }

    return 0;
}
We have two strings. We compare them using both case sensitive and case insensitive string comparison.

if (lstrcmpW(s1, s2) == STR_EQUAL) {

      wprintf(L"%ls and %ls are equal\n", s1, s2);
} else {

      wprintf(L"%ls and %ls are not equal\n", s1, s2);
}
If the lstrcmpW() function returns STR_EQUAL, which is defined to 0, then we print to the console that the two strings are equal. Otherwise we print that they are not equal.

C:\Users\Jano\Documents\Pelles C Projects\strings\WinapiStringCompare>WinapiStringCompare.exe
Strong and strong are not equal
When applying case insensitive comparison:
Strong and strong are equal
The WinapiStringCompare.exe program gives the above output.

Filling a buffer

Filling a buffer with formatted data is essential in C programming. The wsprintfW() function writes formatted data to the specified buffer.

int __cdecl wsprintfW(LPWSTR lpOut, LPCWSTR lpFmt, ... );
The function's first parameter is the buffer that is to receive the formatted output. The second is a string containing format-control specifications. Then we have one or more optional arguments which correspond to format-control specifications.

winapi_string_fillbuffer.c
#include <windows.h>
#include <wchar.h>

#pragma comment(lib, "User32.lib")

int wmain(void) {

    SYSTEMTIME st = {0};
    wchar_t buf[128] = {0};

    GetLocalTime(&st);
    wsprintfW(buf, L"Today is %lu.%lu.%lu\n", st.wDay, 
        st.wMonth, st.wYear);

    wprintf(buf);

    return 0;
}
We build a string which is filled with the current date.

wchar_t buf[128] = {0};
In this particular case we can safely assume that the string will not exceed 128 characters.

GetLocalTime(&st);
The GetLocalTime() function retrieves the current local date and time.

wsprintfW(buf, L"Today is %lu.%lu.%lu\n", st.wDay, 
    st.wMonth, st.wYear);
The wsprintfW() fills the buffer with a wide string. Arguments are copied to the string according to the format specifier.

wprintf(buf);
The content of the buffer is printed to the console.

C:\Users\Jano\Documents\Pelles C Projects\strings\WinapiStringFillBuffer>WinapiStringFillBuffer.exe
Today is 11.2.2016
This is the output of the WinapiStringFillBuffer.exe example.

Character types

Characters have various types. They can be digits, spaces, letters, punctuation, or control characters.

BOOL WINAPI GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr,
    int cchSrc, LPWORD lpCharType);
The GetStringTypeW() function retrieves character type information for the characters in the specified Unicode string. The first parameter is a flag specifying the info types.

Flag	Meaning
CT_CTYPE1	Retrieve character type information.
CT_CTYPE2	Retrieve bidirectional layout information.
CT_CTYPE3	Retrieve text processing information.
Table: Character info types
The second parameter is the Unicode string for which to retrieve the character types.

The third parameter is the size of the string. The final parameter is a pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. The array will contain one word corresponding to each character in the source string.

The GetStringTypeW() function returns a value which is a combination of types. We can query a specific type with the & operator.

Value	Meaning
C1_DIGIT	Decimal digits
C1_SPACE	Space characters
C1_PUNCT	Punctuation
C1_CNTRL	Control characters
C1_ALPHA	Any linguistic character
Table: Partial list of character types
The function returns 0 on failure.

winapi_string_types.c
#include <windows.h>
#include <wchar.h>
#include <stdbool.h>

int wmain(void) {

    wchar_t str[] = L"7 white, 3 red roses.\n";

    int alphas = 0;
    int digits = 0;
    int spaces = 0;
    int puncts = 0;
    int contrs = 0;

    int size = lstrlenW(str);
    WORD types[size];
    ZeroMemory(types, size);

    bool rv = GetStringTypeW(CT_CTYPE1, str, size, types);

    if (!rv) {
    
        wprintf(L"Could not get character types (%ld)", GetLastError());
        return EXIT_FAILURE;
    }

    for (int i=0; i<size; i++) {

        if (types[i] & C1_ALPHA) {
        
            alphas++;
        }

        if (types[i] & C1_DIGIT) {
        
            digits++;
        }

        if (types[i] & C1_SPACE) {
        
            spaces++;
        }

        if (types[i] & C1_PUNCT) {
        
            puncts++;
        }

        if (types[i] & C1_CNTRL) {
        
            contrs++;
        }
    }

    wprintf(L"There are %ld letter(s), %ld digit(s), "
        L"%ld space(s), %ld punctuation character(s), "
        L"and %ld control character(s)\n", alphas, digits, 
        spaces, puncts, contrs);  

    return 0;
}
We have a short sentence. The GetStringTypeW() function is used to determine the character types of the string.

wchar_t str[] = L"7 white, 3 red roses.\n";
This is a short sentence consisting of various wide characters.

int alphas = 0;
int digits = 0;
int spaces = 0;
int puncts = 0;
int contrs = 0;
These variables will be used to count letters, digits, spaces, punctuation, and control characters.

int size = lstrlenW(str);
WORD types[size];
ZeroMemory(types, size);
We get the size of the string and create and array of values. The size does not include the NULL terminating character. We can add 1 to include it. It will be counted as a control character.

bool rv = GetStringTypeW(CT_CTYPE1, str, size, types);
We get the character types of the sentence. The types array is filled with character type values.

if (types[i] & C1_DIGIT) {
  digits++;
}
If the value contains the C1_DIGIT flag, we increase the digits counter.

C:\Users\Jano\Documents\Pelles C Projects\strings\WinapiStringTypes>WinapiStringTypes.exe
There are 13 letter(s), 2 digit(s), 5 space(s), 2 punctuation character(s), 
and 1 control character(s)
This is the output of the WinapiStringTypes.exe example.

Windows API Shell Lightweight Utility functions

These functions are specific to Windows OS; they are available in the Shlwapi.lib.

Trimming a string

The StrTrimW() function removes specified leading and trailing characters from a string. It returns true if any characters were removed; otherwise, false.

BOOL WINAPI StrTrimW(LPWSTR psz, LPCWSTR pszTrimChars);
The first parameter is a pointer to the string to be trimmed. When this function returns successfully, psz receives the trimmed string. The second parameter is a pointer to a string that contains the characters to trim from psz.

winapi_shell_trim.c
#include <windows.h>
#include <wchar.h>
#include <stdbool.h>
#include "Shlwapi.h"

#pragma comment(lib, "Shlwapi.lib")

int wmain(void) {

    wchar_t buf[] = L"23tennis74";
    wchar_t trim[] = L"0123456789";

    wprintf(L"Original string: %ls\n", buf);

    bool r = StrTrimW(buf, trim);

    if (r == true) {
        
        wprintf(L"The StrTrim() trimmed some characters\n", buf);
    } else {

        wprintf(L"No characters were trimmed\n", buf);
    }

    wprintf(L"Trimmed string: %ls\n", buf);

    return 0;
}
In the example, we remove any digits from a string.

wchar_t buf[] = L"23tennis74";
We will remove all digits from this string.

wchar_t trim[] = L"0123456789";
This string contains all characters to be removed.

bool r = StrTrimW(buf, trim);
With the StrTrimW() function, we trim digits from the buffer.

C:\Users\Jano\Documents\Pelles C Projects\strings\ShellTrimString>ShellTrimString.exe
Original string: 23tennis74
The StrTrim() trimmed some characters
Trimmed string: tennis
This is the output of the ShellTrimString.exe example.

Converting strings to integers

The StrToIntExW() converts a string representing a decimal or hexadecimal number to an integer. The function returns true on success.

BOOL WINAPI StrToIntExW(LPCWSTR pszString, DWORD dwFlags, int *piRet);
The first parameter is a pointer to the string to be converted. The second parameter is one of the flags that specify how pszString should be parsed for its conversion to an integer. The third parameter is a pointer to an int that receives the converted string.

winapi_shell_convert.c
#include <windows.h>
#include <wchar.h>
#include <stdbool.h>
#include "Shlwapi.h"

#pragma comment(lib, "Shlwapi.lib")

int wmain(void) {

    wchar_t str1[] = L"512";
    wchar_t str2[] = L"0xAB12";
    int n = 0;

    bool r = StrToIntExW(str1, STIF_DEFAULT, &n);

    if (r == true) {

        wprintf(L"The value is %d\n", n);
    } else {

        wprintf(L"The first conversion failed\n");
        return 1; 
    }

    r = StrToIntExW(str2, STIF_SUPPORT_HEX, &n);

    if (r == true) {

        wprintf(L"The value is %d\n", n);
    } else {

        wprintf(L"The second conversion failed\n");
        return 1; 
    }

    return 0;
}
In the example, we convert two strings; one representing a decimal value and one a hexadecimal one.

wchar_t str1[] = L"512";
wchar_t str2[] = L"0xAB12";
The first string represents a decimal number; the second string represents a hexadecimal number.

bool r = StrToIntExW(str1, STIF_DEFAULT, &n);
With the StrToIntExW() function, we convert the first string into an integer. The STIF_DEFAULT flag tells the function to convert a decimal value.

r = StrToIntExW(str2, STIF_SUPPORT_HEX, &n);
With the STIF_SUPPORT_HEX flag, we tell the function to convert a hexadecimal value.

C:\Users\Jano\Documents\Pelles C Projects\strings\ShellConvertString>ShellConvertString.exe
The value is 512
The value is 43794
This is the output of the ShellConvertString.exe program.

Searching strings

The StrStrW() function finds the first occurrence of a substring within a string. The comparison is case-sensitive.

LPWSTR WINAPI StrStrW(LPCWSTR pszFirst, LPCWSTR pszSrch);
The first parameter is a pointer to the string to search. The second parameter is a pointer to the substring to search for. The function returns the address of the first occurrence of the matching substring if successful, or NULL otherwise.

winapi_shell_search.c
#include <windows.h>
#include <wchar.h>
#include "Shlwapi.h"

#pragma comment(lib, "Shlwapi.lib")

int wmain(void) {

    wchar_t buf[] = L"Today is a rainy day.";
    wchar_t *search_word = L"rainy";
    int len = wcslen(search_word); 
   
    LPWSTR pr = StrStrW(buf, search_word);

    if (pr == NULL) {
        
        wprintf(L"No match\n", buf);
    } else {
        
        wprintf(L"%.*ls is found\n", len, pr);
    }

    return 0;
}
In the code example, we search for a word within a sentence.

wchar_t buf[] = L"Today is a rainy day.";
We search for a word from this sentence.

wchar_t *search_word = L"rainy";
This is the word that we search for.

LPWSTR pr = StrStrW(buf, search_word);
The StrStrW() function searches for a word within the sentence. If it succeeds, it returns a pointer to the matching substring.

C:\Users\Jano\Documents\Pelles C Projects\strings\ShellSearchString>ShellSearchString.exe
rainy is found
This is the output of the ShellSearchString.exe program.

Windows API StrSafe functions

To increase application security, StrSafe functions were released. These functions require the size of the destination buffer as an input. The buffers are guaranteed to be null-terminated. The functions return error codes; this enables proper error handling.

Each of the functions is available in a corresponding character count Cch or byte count Cb version.

The string length

The StringCchLengthW() and StringCbLengthW() functions enable to determine the lenght of the string in characters and bytes.

HRESULT StringCchLengthW(LPCWSTR psz, size_t cchMax, size_t *pcch);
HRESULT StringCbLengthW(LPCWSTR psz, size_t cbMax, size_t *pcb);
The first parameter of the functions is a string whose length is to be checked. The second parameter is the maximum number of characters (bytes) allowed in the psz parameter. This value cannot exceed STRSAFE_MAX_CCH. The third parameter is the number of characters (bytes) in psz, not including the terminating null character.

The functions return S_OK on success and STRSAFE_E_INVALID_PARAMETER on failure. The functions fail if the value in psz is NULL, cchMax is larger than STRSAFE_MAX_CCH, or psz is longer than cchMax. The SUCCEEDED and FAILED macros can be used to check the return values of the functions.

safe_length.c
#include <windows.h>
#include <strsafe.h>
#include <wchar.h>

int wmain(void) { 

    wchar_t str[] = L"ZetCode";
    size_t target_size = 0;

    size_t size = sizeof(str);

    HRESULT r = StringCbLengthW(str, size, &target_size);
    
    if (SUCCEEDED(r)) {

        wprintf(L"The string has %lld bytes\n", target_size);
    } else {

        wprintf(L"StringCbLengthW() failed\n"); 
        return 1;
    }

    size = sizeof(str)/sizeof(wchar_t);

    r = StringCchLengthW(str, size, &target_size);
    
    if (SUCCEEDED(r)) {

        wprintf(L"The string has %lld characters\n", target_size);
    } else {

        wprintf(L"StringCchLengthW() failed\n"); 
        return 1;
    }

    return 0;
}
The code example determines the lenght of a given string in characters and bytes.

wchar_t str[] = L"ZetCode";
We are going to determine the length of this string.

size_t target_size = 0;
The target_size variable is filled with the counted values when the functions return.

size_t size = sizeof(str);
With the sizeof operator, we get the size of the array of characters in bytes. The value serves as a maximum allowable number of characters in the string for the StringCbLengthW() function.

HRESULT r = StringCbLengthW(str, size, &target_size);
With the StringCbLengthW() function we determine the length of the string in bytes. The length is stored in the target_size variable.

if (SUCCEEDED(r)) {

    wprintf(L"The string has %lld bytes\n", target_size);
} else {

    wprintf(L"StringCbLengthW() failed\n"); 
    return 1;
}
We check the returned value with the SUCCEEDED macro. On success, we print the number of bytes in the string; on error, we print an error message.

size = sizeof(str)/sizeof(wchar_t);
Here we determine the maximum allowable characters in the string. The wchar_t is a type for wide characters; its size is compiler specific.

r = StringCchLengthW(str, size, &target_size);
With the StringCchLengthW() function, we get the size of the string in characters.

if (SUCCEEDED(r)) {

    wprintf(L"The string has %lld characters\n", target_size);
} else {

    wprintf(L"StringCchLengthW() failed\n"); 
    return 1;
}
On success, we print the number of characters in the string to the console. On error, we print an error message.

C:\Users\Jano\Documents\Pelles C Projects\strsafe\SafeLength>SafeLength.exe
The string has 14 bytes
The string has 7 characters
The string consists of 14 bytes or 7 characters.

Reading standard input

The StringCchGetsW() reads a line from the standard input, including the newline character.

HRESULT StringCchGetsW(LPWSTR pszDest, size_t cchDest);
The first parameter is the destination buffer, which receives the copied characters. The second parameter is the size of the destination buffer, in characters.

safe_gets.c
#include <windows.h>
#include <strsafe.h>
#include <wchar.h>

#define BUF_LEN 8191

int wmain(void) { 

    wchar_t buf[BUF_LEN] = {0};
    HRESULT r = StringCchGetsW(buf, ARRAYSIZE(buf));   
        
    if (SUCCEEDED(r)) {

        wprintf(L"You have entered: %ls\n", buf);

    } else {

        wprintf(L"StringCchGets() failed\n"); 
        return 1;
    }

    return 0;
}   
In the example we read a line from the standard input. The line is printed back to the console.

#define BUF_LEN 8191
According to the MSDN documentation, the maximum input on command prompt cannot exceed 8191 characters.

wchar_t buf[BUF_LEN] = {0};
We create a buffer for the input string.

HRESULT r = StringCchGetsW(buf, ARRAYSIZE(buf));
The StringCchGetsW() reads a line from the stdin.

C:\Users\Jano\Documents\Pelles C Projects\strsafe\SafeGets>SafeGets.exe
Today is a rainy day.
You have entered: Today is a rainy day.
This is a sample run of the SafeGets.exe program.

Copying strings

The StringCchCopyW() copies one string to another.

HRESULT StringCchCopyW(LPTSTR pszDest, size_t cchDest, LPCWSTR pszSrc);
The first parameter is the destination buffer, which receives the copied string. The second parameter is the size of the destination buffer, in characters. The third parameter is the source string.

safe_copy.c
#include <windows.h>
#include <strsafe.h>
#include <wchar.h>

int wmain(void) { 

    wchar_t *sentence = L"Today is a rainy day.";

    size_t size = wcslen(sentence) + 1;

    wchar_t buf[size];
    ZeroMemory(buf, size); 

    HRESULT r = StringCchCopyW(buf, size, sentence);

    if (SUCCEEDED(r)) {

        wprintf(L"%ls\n", buf);

    } else {

        wprintf(L"StringCchCopyW() failed\n"); 
        return 1;
    }

    return 0;
}
In the code example, we copy one string with the StringCchCopyW() function.

wchar_t *sentence = L"Today is a rainy day.";
This is the string to be copied.

size_t size = wcslen(sentence) + 1;
We determine its length with the wcslen() function; one character is reserved for the newline.

wchar_t buf[size];
ZeroMemory(buf, size);
We create a buffer and with it with zeros with the ZeroMemory() function.

HRESULT r = StringCchCopyW(buf, size, sentence);
With the StringCchCopyW(), we copy the string into the buffer. The size of the destination buffer is provided to ensure that it does not write past the end of this buffer.

C:\Users\Jano\Documents\Pelles C Projects\strsafe\SafeCopy>SafeCopy.exe
Today is a rainy day.
This is the output of the SafeCopy.exe program.

Concatenating strings

The StringCchCatW() concatenates one string to another string.

HRESULT StringCchCatW(LPWSTR pszDest, size_t cchDest, LPCWSTR pszSrc);
The first parameter is the destination buffer. The second parameter is the size of the destination buffer, in characters. The third paramater is the source string that is to be concatenated to the end of the destination buffer.

safe_concat.c
#include <windows.h>
#include <strsafe.h>
#include <wchar.h>

#define BUF_LEN 256

int wmain(void) { 

    wchar_t buf[BUF_LEN] = {0};      

    HRESULT r = StringCchCatW(buf, BUF_LEN, L"Hello "); 
        
    if (FAILED(r)) {

        wprintf(L"StringCchCatW() failed\n"); 
        return 1;
    }

    r = StringCchCatW(buf, BUF_LEN, L"there"); 
    
    if (FAILED(r)) {

        wprintf(L"StringCchCatW() failed\n"); 
        return 1;
    }

    wprintf(L"%ls\n", buf);

    return 0;
}
In the code example, we concatenate two strings with the StringCchCatW() function.

HRESULT r = StringCchCatW(buf, BUF_LEN, L"Hello "); 
The StringCchCatW() function adds the L"Hello " string to the buf array.

r = StringCchCatW(buf, BUF_LEN, L"there"); 
Later, the second string is added to the buffer.

C:\Users\Jano\Documents\Pelles C Projects\strsafe\SafeConcat>SafeConcat.exe
Hello there
This is the output of the SafeConcat.exe program.

Formatting strings

The StringCchPrintfW() function writes formatted data to the destination buffer.

HRESULT StringCchPrintfW(LPWSTR pszDest, size_t cchDest, LPCWSTR pszFormat, ...);
The first parameter is the destination buffer, which receives the formatted string created from pszFormat and its arguments. The second parameter is the destination buffer, in characters. The third parameter is the format string. The following arguments are inserted into the pszFormat string.

safe_format.c
#include <windows.h>
#include <strsafe.h>
#include <wchar.h>

#define BUF_LEN 256

int wmain(void) { 

    wchar_t *word = L"table";
    int count = 6;

    wchar_t buf[BUF_LEN] = {0}; 
    wchar_t *line = L"There are %d %lss";

    HRESULT r = StringCchPrintfW(buf, ARRAYSIZE(buf), line, count, word);   
        
    if (SUCCEEDED(r)) {

        wprintf(L"%ls\n", buf);

    } else {

        wprintf(L"StringCchPrintfW() failed\n"); 
        return 1;
    }

    return 0;
} 
In the code example, we create a formatted string with the StringCchPrintfW() function.

wchar_t *line = L"There are %d %lss";
This is the format string; it has two format specifiers: %d and %ls.

HRESULT r = StringCchPrintfW(buf, ARRAYSIZE(buf), line, count, word);
With the StringCchPrintfW() function, we insert two values into the destination buffer.

C:\Users\Jano\Documents\Pelles C Projects\strsafe\SafeFormat>SafeFormat.exe
There are 6 tables
This is the output of the SafeFormat.exe program.

In this part of the Windows API tutorial, we have worked with strings.

;; --------------------

Date & time in Windows API

In this part of the Windows API tutorial, we will work with date and time. ZetCode has an article dealing with date and time in ANSI C.


 
The SYSTEMTIME structure is used to work with date and time in Windows API. The time can be either coordinated universal time (UTC) or local time. It has the following members:

WORD wYear;
WORD wMonth;
WORD wDayOfWeek;
WORD wDay;
WORD wHour;
WORD wMinute;
WORD wSecond;
WORD wMilliseconds;
The SYSTEMTIME structure is filled either with the GetSystemTime() function or the GetLocalTime() function. We can then access the members of the structure to get the current date or time.

The FILETIME structure contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC). With this value we are able to compute the Windows API epoch or the datetime differences.

DWORD dwLowDateTime;
DWORD dwHighDateTime;
The FILETIME structure has two members: the dwLowDateTime is the low-order part of the file time and the dwHighDateTime is the high-order part of the file time. To get a single value from the two members, we utilise the LARGE_INTEGER union.

The FileTimeToSystemTime() and the SystemTimeToFileTime() functions are used to convert between the two structures.

Local time

Local time is defined as the current time in the user's time zone.

localtime.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    SYSTEMTIME lt = {0};
  
    GetLocalTime(&lt);
  
    wprintf(L"The local time is: %02d:%02d:%02d\n", 
        lt.wHour, lt.wMinute, lt.wSecond);

    return 0;
}
The program prints the local time.

SYSTEMTIME lt = {0};
We declare the SYSTEMTIME structure. The members of this structure are filled by calling a specific time function.

GetLocalTime(&lt);
The GetLocalTime() retrieves the current local date and time. It fills the members of the SYSTEMTIME structure with current date & time values.

wprintf(L"The local time is: %02d:%02d:%02d\n", 
  lt.wHour, lt.wMinute, lt.wSecond);
We print the current local time in the hh:mm:ss format.

C:\Users\Jano\Documents\Pelles C Projects\timedate\LocalTime>LocalTime.exe
The local time is: 20:20:07
This is the sample output.

UTC time

Our planet is a sphere. It revolves round its axis. The Earth rotates towards the east. So the Sun rises at different times in different locations. The Earth rotates once in about 24 hours. Therefore, the world was divided into 24 time zones. In each time zone, there is a different local time. This local time is often further modified by the daylight saving.

There is a pragmatic need for one global time. One global time helps to avoid confusion about time zones and daylight saving time. The UTC (Universal Coordinated time) was chosen to be the primary time standard. UTC is used in aviation, weather forecasts, flight plans, air traffic control clearances, and maps. Unlike local time, UTC does not change with a change of seasons.

The Windows API has the GetSystemTime() function to get the UTC time.

utctime.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    SYSTEMTIME st = {0};
  
    GetSystemTime(&st);
  
    wprintf(L"The UTC time is: %02d:%02d:%02d\n", 
        st.wHour, st.wMinute, st.wSecond);

    return 0;
}
In the example we compute the UTC time.

SYSTEMTIME st = {0};
The UTC time will be stored in the SYSTEMTIME structure.

GetSystemTime(&st);
We retrieve the UTC time using the GetSystemTime() function.

wprintf(L"The UTC time is: %02d:%02d:%02d\n", 
  st.wHour, st.wMinute, st.wSecond);
The UTC time is printed to the console in the hh:mm:ss format.

C:\Users\Jano\Documents\Pelles C Projects\timedate\UtcTime>UtcTime.exe
The UTC time is: 19:25:20
This is the output for the UTC time.

Arithmetic

It is not recommended to do arithmetic operations on values from the SYSTEMTIME structure to obtain relative times. Instead, we convert the SYSTEMTIME structure to a FILETIME structure, copy the resulting FILETIME structure to a ULARGE_INTEGER structure, and use normal 64-bit arithmetic on the ULARGE_INTEGER value. In the end, we convert the FILETIME structure back to SYSTEMTIME structure.

arithmetic.c
#include <windows.h>
#include <wchar.h>

#define NSECS 60*60*3

int wmain(void) {

    SYSTEMTIME st = {0};
    FILETIME ft = {0};

    GetLocalTime(&st);

    wprintf(L"%02d/%02d/%04d %02d:%02d:%02d\n",
        st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, st.wSecond);

    SystemTimeToFileTime(&st, &ft);

    ULARGE_INTEGER u = {0};
     
    memcpy(&u, &ft, sizeof(u));
    u.QuadPart += NSECS * 10000000LLU;
    memcpy(&ft, &u, sizeof(ft));

    FileTimeToSystemTime(&ft, &st);

    wprintf(L"%02d/%02d/%04d %02d:%02d:%02d\n",
        st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, st.wSecond);

    return 0;
}
In the example we add three hours to the current local time value.

#define NSECS 60*60*3
The three hours are expressed in seconds.

GetLocalTime(&st);
With the GetLocalTime() function, we retrieve the current local time.

SystemTimeToFileTime(&st, &ft);
We call the SystemTimeToFileTime() function to convert the SYSTEMTIME structure to the FILETIME structure.

ULARGE_INTEGER u = {0};
The ULARGE_INTEGER structure is created.

memcpy(&u, &ft, sizeof(u));
u.QuadPart += NSECS * 10000000LLU;
memcpy(&ft, &u, sizeof(ft));
We add three hours to the QuadPart member of the ULARGE_INTEGER structure. The member is expressed in 100-nanosecond ticks; therefore, we multiply the NSECS by 10000000LLU.

FileTimeToSystemTime(&ft, &st);
We translate the FILETIME structure back to the SYSTEMTIME structure.

C:\Users\Jano\Documents\Pelles C Projects\timedate\Arithmetic>Arithmetic.exe
01/02/2016 13:28:13
01/02/2016 16:28:13
This is a sample output of the Arithmetic.exe. Three hours were correctly added to the current local time.

Date

The GetLocalTime() function is also used to determine the current date.

today.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    SYSTEMTIME st = {0};
  
    GetLocalTime(&st);
  
    wprintf(L"Today is: %d-%02d-%02d\n", st.wYear, st.wMonth, st.wDay);

    return 0;
}
The above program prints today's date.

SYSTEMTIME st = {0};
We declare a SYSTEMTIME structure.

GetLocalTime(&st);
We fill the SYSTEMTIME members with current local time and date values.

wprintf(L"Today is: %d-%02d-%02d\n", st.wYear, st.wMonth, st.wDay);
The current date is printed to the console. We have chosen the Gregorian big-endian date format.

C:\Users\Jano\Documents\Pelles C Projects\timedate\Today>Today.exe
Today is: 2016-01-30
This is the output of the Today.exe program.

Formatting date

The GetDateFormatEx() function formats a date as a date string for the specified locale.

date_format.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    PDWORD cChars = NULL;
    HANDLE std = GetStdHandle(STD_OUTPUT_HANDLE);   
    
    if (std == INVALID_HANDLE_VALUE) {
        wprintf(L"Cannot retrieve standard output handle %d\n", 
            GetLastError());
        return 1;
    }
 
    SYSTEMTIME lt = {0};
    GetLocalTime(&lt);
     
    wchar_t buf[128] = {0};
     
    int r = GetDateFormatEx(LOCALE_NAME_USER_DEFAULT, DATE_LONGDATE, 
                &lt, NULL, buf, sizeof(buf)/sizeof(buf[0]), NULL);

    if (r == 0) {
    
        wprintf(L"GetDateFormatEx function failed %d\n", 
            GetLastError());
            
        CloseHandle(std);
        
        return 1;
    }

    WriteConsoleW(std, buf, wcslen(buf), cChars, NULL);
    
    r = CloseHandle(std);

    if (r == 0) {
    
        wprintf(L"Cannot close console handle %d\n", 
            GetLastError());
        return 1;    
    }
    
    CloseHandle(std);

    return 0;
}
The program prints the current local time in a localized format.

SYSTEMTIME lt = {0};
GetLocalTime(&lt);
The local time is retrieved.

int r = GetDateFormatEx(LOCALE_NAME_USER_DEFAULT, DATE_LONGDATE, 
			&lt, NULL, buf, sizeof(buf)/sizeof(buf[0]), NULL);
The GetDateFormatEx() formats the date in the default locale specified in the regional and language options. The date is printed in a long date format.

WriteConsoleW(std, buf, wcslen(buf), cChars, NULL);
The date is printed to the console.

C:\Users\Jano\Documents\Pelles C Projects\timedate\DateFormat>DateFormat.exe
1. februára 2016
The program prints the date in the Slovak language.

Determining a leap year

A leap year is a year containing an additional day. The reason for an extra day in the calendar is the difference between the astronomical and the calendar year. The calendar year has exactly 365 days, while the astronomical year, the time for the earth to make one revolution around the Sun, is 365.25 days. The difference is 6 hours which means that in four years time we are missing one day. Because we want to have our calendar synchronised with the seasons, we add one day to February each four years. (There are exceptions.) In the Gregorian calendar, February in a leap year has 29 days instead of the usual 28. And the year lasts 366 days instead of the usual 365.

leapyear.c
#include <windows.h>
#include <stdbool.h>
#include <wchar.h>

bool isLeapYear(int);

int wmain(void) {

    int years[] = { 2000, 2002, 2004, 2008, 2012, 2016, 2020,
        1900, 1800, 1600, 1200, 1000 };
  
    int size = sizeof(years) / sizeof(int);

    for (int i=0; i<size; i++) {

        if (isLeapYear(years[i])) {

            wprintf(L"%ld is a leap year\n", years[i]);
        } else {

            wprintf(L"%ld is not a leap year\n", years[i]);
        }
    }

    return 0;
}

bool isLeapYear(int year) {

    if ((year % 100 == 0) && (year % 400 == 0)) {
        return true;
    }
 
    if ((year % 4 == 0) && (year % 100 !=0)) {
        return true;
    }

    return false;
}
We have an array of years. We check all years if they are leap years or not. There is no built-in function to check for a leap year. We have created a custom isLeapYear() function.

int years[] = { 2000, 2002, 2004, 2008, 2012, 2016, 2020,
    1900, 1800, 1600, 1200, 1000 };
This is an array of years that we will check.

for (int i=0; i<size; i++) {

    if (isLeapYear(years[i])) {

        wprintf(L"%ld is a leap year\n", years[i]);
    } else {

        wprintf(L"%ld is not a leap year\n", years[i]);
    }
}
With the for loop we traverse the array. We check if a year is a leap year using the isLeapYear() function.

bool isLeapYear(int year) {

    if ((year % 100 == 0) && (year % 400 == 0)) {
        return true;
    }
 
    if ((year % 4 == 0) && (year % 100 !=0)) {
        return true;
    }

    return false;
}
This is the function for determining a leap year. Leap years are integer multiples of 4. A year that is an integer multiple of 100 is not a leap year, unless it is also an integer multiple of 400, in which case it is also a leap year.

C:\Users\Jano\Documents\Pelles C Projects\timedate\LeapYear>LeapYear.exe
2000 is a leap year
2002 is not a leap year
2004 is a leap year
2008 is a leap year
2012 is a leap year
2016 is a leap year
2020 is a leap year
1900 is not a leap year
1800 is not a leap year
1600 is a leap year
1200 is a leap year
1000 is not a leap year
Output of the LeapYear.exe program.

Uptime

The GetTickCount() function can be used to get the uptime of a computer. It retrieves the number of milliseconds that have elapsed since the system has started.

DWORD WINAPI GetTickCount(void);
The function returns a DWORD value, so the maximum number of days returned is 49.7. To get over this limitation, we can use the GetTickCount64(). The function is available since Windows Vista.

uptime.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {  

    DWORD tc = GetTickCount();

    short seconds = tc / 1000 % 60; 
    short minutes = tc / 1000 / 60 % 60; 
    short hours = tc / 1000 / 60 / 60 % 24; 
    short days = tc / 1000 / 60 / 60 / 24 % 7;  
    short weeks = tc / 1000 / 60 / 60 / 24 / 7 % 52; 

    wprintf(L"Computer has been running for: ");
                    
    if (weeks > 0 && weeks != 1) {

        wprintf(L"%hi weeks ", weeks);
    } else if (weeks == 1) {

        wprintf(L"1 week ");
    }

    if (days > 0 && days != 1) {

        wprintf(L"%hi days ", days);
    } else if (days == 1) {

        wprintf(L"1 day ");
    }

    if (hours > 0 && hours != 1) {

        wprintf(L"%hi hours ", hours);
    } else if (hours == 1) {

        wprintf(L"1 hour ");
    }

    if (minutes > 0 && minutes != 1) {

        wprintf(L"%hi minutes ", minutes); 
    } else if (minutes == 1) {

        wprintf(L"1 minute ");
    }

    wprintf(L"and %hi seconds\n", seconds);

    return 0;
}
The program prints the uptime of a computer. We use the GetTickCount() function. It works correctly if the computer is running less than 49.71 days or 4294967296 ms. After that the DWORD value overflows.

DWORD tc = GetTickCount();
We get the number of milliseconds the computer is running. The maximum number a DWORD variable can store is ULONG_MAX.

short seconds = tc / 1000 % 60; 
short minutes = tc / 1000 / 60 % 60; 
short hours = tc / 1000 / 60 / 60 % 24; 
short days = tc / 1000 / 60 / 60 / 24 % 7;  
short weeks = tc / 1000 / 60 / 60 / 24 / 7 % 52; 
We compute the seconds, minutes, hours, days, and weeks.

if (weeks > 0 && weeks != 1) {

  wprintf(L"%hi weeks ", weeks);
} else if (weeks == 1) {

  wprintf(L"1 week ");
}
If the computer is running one or more weeks, we either print the weeks variable or "1 week" string to the console.

C:\winapi\examples2\datetime\Uptime>Uptime.exe
Computer has been running for: 3 hours 31 minutes and 7 seconds
Sample output.

Day of week

The wDayOfWeek member of the SYSTEMTIME structure stores the day of the week. The values are 1..7 where 1 is Sunday, 2 Monday,... 7 Saturday.

dayofweek.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    SYSTEMTIME st = {0};

    wchar_t *dn[] = { L"Sunday", L"Monday", L"Tuesday", 
        L"Wednesday", L"Thursday", L"Friday", L"Saturday" };

    GetLocalTime(&st);
    wprintf(L"Today is %ls\n", dn[st.wDayOfWeek]);

    return 0;
}
The code prints the current day of the week to the console.

wchar_t *dn[] = { L"Sunday", L"Monday", L"Tuesday", 
  L"Wednesday", L"Thursday", L"Friday", L"Saturday" };
We store the names of the days in a string array.

GetLocalTime(&st);
wprintf(L"Today is %ls\n", dn[st.wDayOfWeek]);
These lines retrieve and print the current day of the week.

C:\Users\Jano\Documents\Pelles C Projects\timedate\DayOfWeek>DayOfWeek.exe
Today is Sunday
This is the output.

The epoch

An epoch is an instant in time chosen as the origin of a particular era. For example in western Christian countries the time epoch starts from day 0, when Jesus was born (is believed to be born). Another example is the French Republican Calendar which was used for twelve years. The epoch was the beginning of the Republican Era which was proclaimed on September 22, 1792, the day the First Republic was declared and the monarchy abolished. Computers have their epochs too. One of the most popular is the Unix time. The Unix epoch is the time 00:00:00 UTC on 1 January 1970 (or 1970-01-01T00:00:00Z ISO 8601). The date and time in a computer is determined according to the number of seconds or clock ticks that have elapsed since the defined epoch for that computer or platform.

Windows operating system has several epochs. Microsoft Excel, MS SQL Server or FAT32 filesystem have different time epochs. The Windows API epoch is January 1, 1601, 00:00:00 UTC. The reason for choosing this date was the 400th anniversary of accepting of the Gregorian calendar. The anniversary falled at the time when Windows NT was designed. The FILETIME structure contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).

windows_epoch.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    FILETIME ft = {0};
  
    GetSystemTimeAsFileTime(&ft);

    LARGE_INTEGER li = {0};    

    li.LowPart = ft.dwLowDateTime;
    li.HighPart = ft.dwHighDateTime;

    long long int hns = li.QuadPart;
    
    wprintf(L"%lli hundreds of nanoseconds have elapsed " 
        "since Windows API epoch\n", hns);

    return 0;
}
The code example computes the number of 100-nanosecond intervals elapsed from the Windows API epoch till this moment.

FILETIME ft = {0};
We declare the FILETIME structure. It has two members. The dwLowDateTime holds the low-order part of the file time. The dwHighDateTime holds the high-order part of the file time.

LARGE_INTEGER li = {0};
The LARGE_INTEGER is a union which helps us to convert the members of the FILETIME structure to 100-nanosecond intervals.

li.LowPart = ft.dwLowDateTime;
li.HighPart = ft.dwHighDateTime;
The values of the FILETIME structure are copied to the large integer union members.

long long int hns = li.QuadPart;
The QuadPart member stores the number of hundreds of nanoseconds determined from the LowPart and HighPart members. It is a huge number stored as a 64-bit integer.

wprintf(L"%lli hundreds of nanoseconds have elapsed " 
  "since Windows API epoch\n", hns);
The value is printed to the console.

C:\Users\Jano\Documents\Pelles C Projects\timedate\WindowsEpoch>WindowsEpoch.exe
130987330019489987 hundreds of nanoseconds have elapsed since Windows API epoch
This is the sample output.

The following example converts the Windows API time into Unix time.

unix_time.c
#include <windows.h>
#include <wchar.h>

#define WINDOWS_TICKS_PER_SEC 10000000
#define EPOCH_DIFFERENCE 11644473600LL

long long WindowsTicksToUnixSeconds(long long);

int wmain(void) {

    FILETIME ft = {0};
  
    GetSystemTimeAsFileTime(&ft);

    LARGE_INTEGER li = {0};    

    li.LowPart = ft.dwLowDateTime;
    li.HighPart = ft.dwHighDateTime;

    long long int hns = li.QuadPart;
    
    wprintf(L"Windows API time: %lli\n", hns);

    long long int utm = WindowsTicksToUnixSeconds(hns);

    wprintf(L"Unix time: %lli\n", utm);

    return 0;
}

long long int WindowsTicksToUnixSeconds(long long windowsTicks) {

     return (windowsTicks / WINDOWS_TICKS_PER_SEC - EPOCH_DIFFERENCE);
}
The example prints the Windows API time and the Unix time to console.

#define EPOCH_DIFFERENCE 11644473600LL
The difference between the two epochs is 11644473600LL. Note that leap seconds were introduced in 1972, so we do not take them into account.

long long int WindowsTicksToUnixSeconds(long long windowsTicks) {

     return (windowsTicks / WINDOWS_TICKS_PER_SEC - EPOCH_DIFFERENCE);
}
The function translates windows ticks into unix time seconds.

C:\Users\Jano\Documents\Pelles C Projects\timedate\UnixTime>UnixTime.exe
Windows API time: 130987431026414297
Unix time: 1454269502
This is the output of the UnixTime.exe example.

Days until XMas

The Windows API does not have any functions to calcuate the difference between two days. We have to do the math ourselves.

days_to_xmas.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    FILETIME ft1 = {0};
    FILETIME ft2 = {0};
    SYSTEMTIME st = {0};  
    LARGE_INTEGER li1 = {0};    
    LARGE_INTEGER li2 = {0}; 

    st.wYear = 2016;
    st.wMonth = 12;
    st.wDay = 25;
 
    int r = SystemTimeToFileTime(&st, &ft1);

    if (r == 0) {

        wprintf(L"Failed to convert system time to file time\n (%d)", 
            GetLastError());
        return 1;
    }
  
    GetSystemTimeAsFileTime(&ft2);
   
    li1.LowPart = ft1.dwLowDateTime;
    li1.HighPart = ft1.dwHighDateTime;
 
    li2.LowPart = ft2.dwLowDateTime;
    li2.HighPart = ft2.dwHighDateTime;

    long long int dif = li1.QuadPart - li2.QuadPart;

    int days2xmas = dif / 10000000L / 60 / 60 / 24;

    if (days2xmas == 1) {

        wprintf(L"There is one day until Christmas\n", days2xmas);
    } else if (days2xmas == 0) {

        wprintf(L"Today is Chritmas\n");
    } else {

        wprintf(L"There are %d days until Christmas\n", days2xmas);
    }
  
    return 0;
}
The code example computes the number of days until the Christmas.

FILETIME ft1 = {0};
FILETIME ft2 = {0};
SYSTEMTIME st = {0};  
LARGE_INTEGER li1 = {0};    
LARGE_INTEGER li2 = {0}; 
We need FILETIME, SYSTEMTIME structures and LARGE_INTEGER unions to do our computations.

st.wYear = 2016;
st.wMonth = 12;
st.wDay = 25;
The SYSTEMTIME structure is filled with the values for the Christmas day.

int r = SystemTimeToFileTime(&st, &ft1);
The system time for the Christmas day is converted to file time.

GetSystemTimeAsFileTime(&ft2);
We get the current date as a file time using the GetSystemTimeAsFileTime() function.

li1.LowPart = ft1.dwLowDateTime;
li1.HighPart = ft1.dwHighDateTime;

li2.LowPart = ft2.dwLowDateTime;
li2.HighPart = ft2.dwHighDateTime;
We fill the two unions with the low-order and high-order parts of the file time.

long long int dif = li1.QuadPart - li2.QuadPart;
The difference between the two dates is computed.

int days2xmas = dif / 10000000L / 60 / 60 / 24;
The difference is expressed in 100-nanoseconds. This value is converted to days.

C:\Users\Jano\Documents\Pelles C Projects\timedate\DaysToXmas>DaysToXmas.exe
There are 328 days until Christmas
On January 31, 2016 we get this output.

Comparing times

The CompareFileTime() function can be used to compare two file times. The function returns -1 when the first time specified is earlier. It returns 0, when the two times are equal. And it returns 1 when the first time is later than the second file time.

compare_time.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    SYSTEMTIME st1 = {0};
    SYSTEMTIME st2 = {0};
    FILETIME ft1 = {0};
    FILETIME ft2 = {0};

    st1.wYear = 2015;
    st1.wMonth = 4;
    st1.wDay = 12;

    st2.wYear = 2015;
    st2.wMonth = 5;
    st2.wDay = 12;

    int r1 = SystemTimeToFileTime(&st1, &ft1);

    if (r1 == 0) {

        wprintf(L"Failed to convert system time to file time\n (%d)", 
            GetLastError());
        return 1;
    }
  
    int r2 = SystemTimeToFileTime(&st2, &ft2);

    if (r2 == 0) {

        wprintf(L"Failed to convert system time to file time\n (%d)", 
            GetLastError());
        return 1;
    }
    
    short ct = CompareFileTime(&ft1, &ft2);

    if (ct == -1) {

        wprintf(L"4/12/2015 comes before 5/12/2015\n");
    } else if (ct == 0) {

        wprintf(L"4/12/2015 is equal to 5/12/2015\n");
    } else if (ct == 1) {

        wprintf(L"4/12/2015 comes after 5/12/2015\n");
    }

    return 0;
}
We have two time values. We use the CompareFileTime() to figure out which time is earlier.

st1.wYear = 2015;
st1.wMonth = 4;
st1.wDay = 12;

st2.wYear = 2015;
st2.wMonth = 5;
st2.wDay = 12;
The two times are defined.

int r1 = SystemTimeToFileTime(&st1, &ft1);

if (r1 == 0) {

	wprintf(L"Failed to convert system time to file time\n (%d)", 
		GetLastError());
	return 1;
}

int r2 = SystemTimeToFileTime(&st2, &ft2);

if (r2 == 0) {

	wprintf(L"Failed to convert system time to file time\n (%d)", 
		GetLastError());
	return 1;
}
The system times are converted to file times using the SystemTimeToFileTime() function calls.

short ct = CompareFileTime(&ft1, &ft2);
The two file times are compared with the CompareFileTime() function.

if (ct == -1) {

	wprintf(L"4/12/2015 comes before 5/12/2015\n");
} else if (ct == 0) {

	wprintf(L"4/12/2015 is equal to 5/12/2015\n");
} else if (ct == 1) {

	wprintf(L"4/12/2015 comes after 5/12/2015\n");
}
Depending on the returned value, we print a message to the console.

C:\Users\Jano\Documents\Pelles C Projects\timedate\CompareTime>CompareTime.exe
4/12/2015 comes before 5/12/2015
This is the output of the CompareTime.exe program.

Time zones

A time zone is a region throughout which the same standard time is used. There are 24 time zones in the world.

UTC = local time + bias
The bias is the difference, in minutes, between UTC time and local time.

Retrieving time zone

The GetTimeZoneInformation() is used to get time zone information. The information is stored in the TIME_ZONE_INFORMATION structure.

get_time_zone.c
#include <windows.h>
#include <wchar.h>

int wmain(void) {

    TIME_ZONE_INFORMATION tzi = {0};
    
    int r = GetTimeZoneInformation(&tzi);

    if (r == TIME_ZONE_ID_INVALID) {

        wprintf(L"Failed to get time zone %d", GetLastError());
        return 1;
    }

    wprintf(L"Time zone: %ls\n", tzi.StandardName);
    wprintf(L"The bias is: %ld minutes\n", tzi.Bias);

    return 0;
}
The example prints the user's time zone.

TIME_ZONE_INFORMATION tzi = {0};
The TIME_ZONE_INFORMATION structure stores settings for a time zone.

int r = GetTimeZoneInformation(&tzi);
The GetTimeZoneInformation() function retrieves the current time zone settings.

wprintf(L"Time zone: %ls\n", tzi.StandardName);
The StandardName member of the TIME_ZONE_INFORMATION structure stores the name of our time zone.

wprintf(L"The bias is: %ld minutes\n", tzi.Bias);
We print the bias value.

C:\Users\Jano\Documents\Pelles C Projects\timedate\GetTimeZone>GetTimeZone.exe
Time zone: Central Europe Standard Time
The bias is: -60 minutes
Our time zone is Central Europe Standard Time (CEST) and the bias is -60 minutes.

Converting local time to universal time

The TzSpecificLocalTimeToSystemTime() function converts local time to UTC time. The function takes into account whether daylight saving time (DST) is in effect for the local time to be converted.

localtime_to_universaltime.c
#include <windows.h>
#include <wchar.h>

int wmain(void) { 

    SYSTEMTIME lt = {0};
    GetLocalTime(&lt);

    TIME_ZONE_INFORMATION tzi = {0};
    GetTimeZoneInformation(&tzi);

    SYSTEMTIME utm = {0};

    int r = TzSpecificLocalTimeToSystemTime(&tzi, &lt, &utm);
    
    if (r == 0) {

        wprintf(L"Failed to convert local time to system time %d\n)", 
            GetLastError());
        return 1;
    }

    wprintf(L"Date: %d/%d/%d\n", lt.wMonth, lt.wDay, lt.wYear);

    wprintf(L"The local time is: %02d:%02d:%02d\n", 
        lt.wHour, lt.wMinute, lt.wSecond);

    wprintf(L"The universal time is: %02d:%02d:%02d\n", 
        utm.wHour, utm.wMinute, utm.wSecond);

    return 0;
}
The example converts the local time into the universal time.

SYSTEMTIME lt = {0};
GetLocalTime(&lt);
The current local time is retrieved with the GetLocalTime() function.

TIME_ZONE_INFORMATION tzi = {0};
GetTimeZoneInformation(&tzi);
The time zone settings are determined with the GetTimeZoneInformation() function.

int r = TzSpecificLocalTimeToSystemTime(&tzi, &lt, &utm);
The TzSpecificLocalTimeToSystemTime() translates local time into universal time, taking daylight saving into account.

wprintf(L"The local time is: %02d:%02d:%02d\n", 
	lt.wHour, lt.wMinute, lt.wSecond);
The local time is printed to console.

wprintf(L"The universal time is: %02d:%02d:%02d\n", 
	utm.wHour, utm.wMinute, utm.wSecond);
The universal time is printed to console.

C:\Users\Jano\Documents\Pelles C Projects\timedate\LocalTimeToUniversalTime>LocalTimeToUniversalTime.exe
Date: 2/1/2016
The local time is: 11:39:48
The universal time is: 10:39:48
In the CEST time zone, on February 1, 2016, we get the above output.

In this part of the Windows API tutorial, we have worked with date & time.

;; ----------------------------

A window in Windows API

A window is a rectangular area of the screen where the application displays output and receives input from the user. Everything is a window in Windows. At least from the programmer's point of view. A main window, a button, a static text even an icon; all are windows. A static text is only a special kind of a window, so is the desktop area.


 
wWinMain() function

Every Windows UI application must have at least two functions: the WinMain function and the window procedure. The WinMain function is the entry point to a Windows UI application. It initialises the application, shows the application window on the screen, and enters the main loop. In our examples, we use the wWinMain() function prototype, which is used for creating Unicode UI programs.

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    PWSTR pCmdLine, int nCmdShow);
The hInstance is a handle of an instance. It is a 32-bit number identifying the instance of our program within the OS environment. This number is given by Windows when the program starts executing. The hPrevInstance parameter is always NULL; it is a legacy from the 16-bit Windows. Windows programs can also be started from the command line. The parameters given are stored in pCmdLine parameter. The nCmdShow value specifies how the window will be displayed: minimised, maximised, or hidden.

The wWinMain() function terminates when it receives the WM_QUIT message.

Registering a window class

Before we can create a window, we must register its class within the Windows. Many controls have their window classes already registered. So when we create a button or a static text, we do not need to register a window class for them. To register a window class, we must create and fill a WNDCLASS structure. We set the window style, extra allocation bytes, window class name, handle of the program instance, background brush, optional menu name, window procedure, handle of the cursor, and an icon. Then the RegisterClassW() function is called.

Creating a window

The window is created by calling the CreateWindowW() function.

HWND CreateWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, 
  DWORD dwStyle, int x, int y, int nWidth, int nHeight, 
  HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam); 
The lpClassName uniquely identifies the window. It is the name under which we registered the window. The lpWindowName is the window name. Its effect depends on the context—it can be title of the window in parent windows or a label in child windows like button or static text. Windows can be created using several styles. For this, we have the dwStyle parameter. The x, y specify the initial horizontal and vertical position of the window. The nWidth and nHeight specify the window width and height. The hWndParent is a handle to the parent window. For windows that do not have parents, we use NULL. For a parent window the hMenu is an optional handle to the menu, for a child window, it is a control identifier. The hInstance is a handle to the program instance. The lpParam is the last parameter, it is an optional value passed to the window during the WM_CREATE message. The CreateWindowW() function returns a handle to the newly created window.

Messages

The WinMain() function creates a message loop. It is an endless cycle which runs during the life of the application. Message loop is a programming construct that waits for and dispatches events or messages in a program. Windows communicate using messages. A message is an integer value that identifies a specific event—a button click, resizing of the window, or closing of an application. There can be multiple messages created in one moment. The messages cannot be processed all at the same time; therefore they are stored in a message queue. The message enters the message queue and waits until it is processed. The GetMessage() function retrieves the message from the message queue. The DispatchMessage() function dispatches a message to a window procedure. If the application obtains character input, we include the TranslateMessage() function in the loop.

Window procedure

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
Every window has an associated window procedure. It is a function that receives messages. The hwnd is a handle to the window that is going to receive the message. The uMsg is the message. The wParam and lParam parameters provide additional message information. The values of these parameters depend on the message type. The messages come from the user or from the operating system. We react to a message or we call the default window procedure to provide default processing. Most messages are sent to the default window procedure. The default window procedure is called DefWindowProcW(). It is called with the same parameters as the normal window procedure.

A simple window

The following example shows a skeletal Windows application.

simplewindow.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    PWSTR pCmdLine, int nCmdShow) {
    
    MSG  msg;    
    HWND hwnd;
    WNDCLASSW wc;

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpszClassName = L"Window";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpszMenuName  = NULL;
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
  
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"Window",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100, 100, 350, 250, NULL, NULL, hInstance, NULL);  

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    while (GetMessage(&msg, NULL, 0, 0)) {
  
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
      case WM_DESTROY:
      
          PostQuitMessage(0);
          break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
We are going to explain the example code step by step.

#include <windows.h>
This is a header file for the C programming language. It contains all function declarations in the API, all common macros and all the data types. The Windows API is added to the C programming project by linking the necessary libraries—kernel32.lib, user32.lib, gdi32.lib—and by including the <windows.h> header file.

wc.style = CS_HREDRAW | CS_VREDRAW;
We set the window style here. The CS_HREDRAW and CS_VREDRAW flags mean that whenever there is a movement or size adjustment of the height or width of the window, the entire window is redrawn.

wc.cbClsExtra    = 0;
wc.cbWndExtra    = 0;
In our example, we do not use the additional bytes. So we set the members to zero. The most common use of those two attributes is window subclassing.

wc.lpszClassName = L"Window";
Window is a class name for this particular window type. We will use this class name when creating the window. The L character precedes wide strings.

wc.hInstance = hInstance;
We set the instance of our program.

wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
Here we set the background brush. It is the colour that is used to paint the client area of the window.

wc.lpszMenuName  = NULL;
In our example, we do not create a menu.

wc.lpfnWndProc = WndProc;
We provide the window procedure for the window class.

wc.hCursor = LoadCursor(NULL, IDC_ARROW);
We set the cursor for our application. We load the cursor from system resources by using the LoadCursor() function. IDC_ARROW is a value for a standard arrow cursor.

wc.hIcon   = LoadIcon(NULL, IDI_APPLICATION);
We set the icon for our application. The icon is retrieved from system resources with the LoadIcon() function. IDI_APPLICATION is a value for a default application icon.

RegisterClassW(&wc);
We register the window class with the system.

ShowWindow(hwnd, nCmdShow);
UpdateWindow(hwnd);
These two lines show the window on the screen. The nCmdShow specifies how we display the window on the screen.

while (GetMessage(&msg, NULL, 0, 0)) {

  DispatchMessage(&msg);
}
This is the message loop. We receive messages from the message queue using the GetMessage() function and dispatch them to the window procedure using the DispatchMessage() function.

return (int) msg.wParam;
At the end of the application, the exit code is returned to the system.

switch(msg) {

  case WM_DESTROY:
  
    PostQuitMessage(0);
    break;
}

return DefWindowProcW(hwnd, msg, wParam, lParam);
In the window procedure, we react to the WM_DESTROY message. The PostQuitMessage() sends the WM_QUIT message to the message queue. All other messages are sent to the default processing using the DefWindowProcW() function.

A window
Figure: A window
In this part of the Windows API tutorial, we have created a basic window.

;; --------------------------

First steps in UI

In this part of the Windows API tutorial, we will create some simple UI examples.


 
Simple program

Here is a very simple program. It will pop up a small dialog box.

simple.c
#include <windows.h>

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                    PWSTR pCmdLine, int CmdShow) {
                    
    MessageBoxW(NULL, L"First Program", L"First", MB_OK);

    return 0;
}
A small dialog box is shown on the screen. It has a caption, a message, and an OK button.

#include <windows.h>
We include the basic function declarations, constants, data types, and structures.

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                    PWSTR pCmdLine, int CmdShow)
The wWinMain() function is an entry point to our application.

MessageBoxW(NULL, L"First Program", L"First", MB_OK);
The MessageBoxW() function displays a simple message box. The first parameter is the owner window. In our case, the dialog box has no owner. The next two parameters provide the message text and the caption. The last parameter defines the message dialog type. The MB_OK value causes the dialog to have one OK button.

Simple message box
Figure: Simple message box
Centering a window

In the next code example, we will center the window on the screen. The SetWindowPos() function changes the size, position, and Z order of a child, a pop-up, or a top-level window.

BOOL WINAPI SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int x, int y,
    int cx, int cy, UINT uFlags);
The first parameter is a handle to the window. The second parameter is a handle to the window to precede the positioned window in the Z order or a special flag; for instance, the HWND_BOTTOM flag places the window at the bottom of the Z order and the HWND_TOP flag at the top of the Z order. The x and y parameters are the new positions of the left and top sides of the window, in client coordinates. The cx and cy are the new width and height dimensions of the window, in pixels. The last parameter is a combination of sizing and positioning flags; for instance SWP_NOMOVE retains the current position (ignores x and y parameters) or SWP_NOSIZE retains the current size (ignores cx and cy parameters).

centering.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CenterWindow(HWND);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR pCmdLine, int nCmdShow) {
                    
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Center";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Center",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 250, 150, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
  
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
        case WM_CREATE: 
      
            CenterWindow(hwnd);
            break;      

        case WM_DESTROY: 
      
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CenterWindow(HWND hwnd) {

    RECT rc = {0};
    
    GetWindowRect(hwnd, &rc);
    int win_w = rc.right - rc.left;
    int win_h = rc.bottom - rc.top;

    int screen_w = GetSystemMetrics(SM_CXSCREEN);
    int screen_h = GetSystemMetrics(SM_CYSCREEN);
    
    SetWindowPos(hwnd, HWND_TOP, (screen_w - win_w)/2, 
        (screen_h - win_h)/2, 0, 0, SWP_NOSIZE);
}
In order to center a window on the screen, we need to have the dimensions of the window and of the screen.

case WM_CREATE: 

    CenterWindow(hwnd);
    break;  
We call the user defined CenterWindow() function during the WM_CREATE message.

GetWindowRect(hwnd, &rc) ;
With the GetWindowRect() function, we retrieve the dimensions of the bounding rectangle of the specified window.

int win_w = rc.right - rc.left;
int win_h = rc.bottom - rc.top;
The window width and height are computed.

int screen_w = GetSystemMetrics(SM_CXSCREEN)
int screen_h = GetSystemMetrics(SM_CYSCREEN);
With the GetSystemMetrics() function, we determine the screen width and height.

SetWindowPos(hwnd, HWND_TOP, (screen_w - win_w)/2, 
    (screen_h - win_h)/2, 0, 0, SWP_NOSIZE);
We use the SetWindowPos() function to position the application window in the center of the screen.

Hot key

In the following example we show how to register a hot key. A hot key is a key combination for executing a specific action. A hot key is registered with the RegisterHotKey() function.

BOOL WINAPI RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk);
The first parameter is a handle to the window that will receive the WM_HOTKEY message generated by the hot key. The second parameter is the ID of the hot key. The third parameter consists of modifiers; keys that must be pressed in combination with the key specified by the vk parameter in order to generate the WM_HOTKEY message. Examples of modifiers include MOD_ALT or MOD_CONTROL. The last parameter is the virtual key code of the hot key.

hotkey.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CenterWindow(HWND);

#define ID_HOTKEY 1

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    HWND hwnd;
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Application";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
 
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"Hot key",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 270, 170, 0, 0, 0, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
        WPARAM wParam, LPARAM lParam) {

    switch(msg) {
   
        case WM_CREATE:

              RegisterHotKey(hwnd, ID_HOTKEY, MOD_CONTROL, 0x43);
              break;

        case WM_HOTKEY:

            if ((wParam) == ID_HOTKEY) {

                CenterWindow(hwnd);
            }
            
            break;

        case WM_DESTROY:
        
            UnregisterHotKey(hwnd, ID_HOTKEY);
            PostQuitMessage(0);            
            break; 
    }
  
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CenterWindow(HWND hwnd) {

    RECT rc = {0};
    
    GetWindowRect(hwnd, &rc);
    int win_w = rc.right - rc.left;
    int win_h = rc.bottom - rc.top;

    int screen_w = GetSystemMetrics(SM_CXSCREEN);
    int screen_h = GetSystemMetrics(SM_CYSCREEN);
    
    SetWindowPos(hwnd, HWND_TOP, (screen_w - win_w)/2, 
        (screen_h - win_h)/2, 0, 0, SWP_NOSIZE);
}
In the example we register a Ctrl + C hot key. It centers the window on the screen.

case WM_CREATE:

      RegisterHotKey(hwnd, ID_HOTKEY, MOD_CONTROL, 0x43);
      break;
During the creation of the window, we register the Ctrl + C hot key with the RegisterHotKey() function.

case WM_HOTKEY:

    if ((wParam) == ID_HOTKEY) {

        CenterWindow(hwnd);
    }
    
    break;
A WM_HOTKEY message is generated when invoking the hot key. We identify our hot key by examining the wParam parameter and call the CenterWindow() function.

case WM_DESTROY:

    UnregisterHotKey(hwnd, ID_HOTKEY);
    PostQuitMessage(0);            
    break; 
When the window is destroyed, we unregister the hot key with the UnregisterHotKey() function. The MSDN is not clear about whether it is compulsory to call this function.

More windows

A window is created from a specific window class. A window class defines a set of behaviours that several windows have in common. Some classes are already predefined in the system. A custom window class must be registered. After that, we can create windows of this new window class. A window is created using the CreateWindowW() function. Its first parameter is the window class name.

Each window has a window procedure. It is a function that is called by the OS when users interact with the window. In the following example, we create three windows: one parent window and two child windows.

morewindows.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK PanelProc(HWND, UINT, WPARAM, LPARAM);

void RegisterRedPanelClass(void);
void RegisterBluePanelClass(void);


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Windows";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Windows",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 250, 180, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
  
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {    
    
    switch(msg) {
  
        case WM_CREATE:

            RegisterRedPanelClass();

            CreateWindowW(L"RedPanelClass", NULL, 
                          WS_CHILD | WS_VISIBLE,
                          20, 20, 80, 80,
                          hwnd, (HMENU) 1, NULL, NULL);

            RegisterBluePanelClass();

            CreateWindowW(L"BluePanelClass", NULL, 
                          WS_CHILD | WS_VISIBLE,
                          120, 20, 80, 80,
                          hwnd, (HMENU) 2, NULL, NULL);
            break;

        case WM_DESTROY:
    
            PostQuitMessage(0);
            return 0; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

LRESULT CALLBACK PanelProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
        case WM_LBUTTONUP:
    
            MessageBeep(MB_OK);
            break;    
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void RegisterRedPanelClass(void) {

    HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));

    WNDCLASSW rwc = {0};
    
    rwc.lpszClassName = L"RedPanelClass";
    rwc.hbrBackground = hbrush;
    rwc.lpfnWndProc   = PanelProc;
    rwc.hCursor       = LoadCursor(0, IDC_ARROW);
    RegisterClassW(&rwc); 
}

void RegisterBluePanelClass(void) {

    HBRUSH hbrush = CreateSolidBrush(RGB(0, 0, 255));

    WNDCLASSW rwc = {0};
    
    rwc.lpszClassName = L"BluePanelClass";
    rwc.hbrBackground = hbrush;
    rwc.lpfnWndProc   = PanelProc;
    rwc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&rwc);
}
We have an application window with two child windows. The two child windows have blue and red backgrounds.

HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
...
rwc.hbrBackground = hbrush;
To create a coloured window background, we create a custom solid brush by calling the CreateSolidBrush() function. To specify a colour, we use the RGB macro. As we know, any colour can be created by combining red, green, and blue colours. Then we set the hbrBackground parameter of the window class structure to this newly created brush.

RegisterRedPanelClass();

CreateWindowW(L"RedPanelClass", NULL, 
                WS_CHILD | WS_VISIBLE,
                20, 20, 80, 80,
                hwnd, (HMENU) 1, NULL, NULL);
First we register a new window class. After this step, we create a window of this class.

Both of our child windows share the PanelProc window procedure. This procedure is called by the Windows OS when we interact with it.

case WM_LBUTTONUP:

    MessageBeep(MB_OK);
    break;    
We interact with our child windows, when we click on them. By left clicking on the child window, the Windows OS calls the child window procedure and sends a WM_LBUTTONUP message. In our example, we call the MessageBeep() function. If we left click on the background of the two child windows, we hear the Windows default beep sound.

void RegisterBluePanelClass(void) {

    HBRUSH hbrush = CreateSolidBrush(RGB(0, 0, 255));

    WNDCLASSW rwc = {0};
    
    rwc.lpszClassName = L"BluePanelClass";
    rwc.hbrBackground = hbrush;
    rwc.lpfnWndProc   = PanelProc;
    rwc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&rwc);
} 
This function registers a new window class. Windows of this window class type have red backgrounds. The edit, button, and static controls are created from predefined window classes, which are already available to all processes. So in these cases we do not need to register a window class for them.

More windows
Figure: More windows
The escape key

Applications are often terminated by pressing the Escape key. A message box is also shown to confirm the termination.

escapekey.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                    PWSTR pCmdLine, int CmdShow) {
                    
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Escape";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
    
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Escape",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 250, 180, 0, 0, hInstance, 0);  

  while (GetMessage(&msg, NULL, 0, 0)) {
  
      TranslateMessage(&msg);
      DispatchMessage(&msg);
  }

  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
        case WM_KEYDOWN:

            if (wParam == VK_ESCAPE) {
      
                int ret = MessageBoxW(hwnd, L"Are you sure to quit?", 
                                  L"Message", MB_OKCANCEL);
                                  
                if (ret == IDOK) {
          
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                }
             }
      
             break;

        case WM_DESTROY:

            PostQuitMessage(0);
            break; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
It is a common practice to ask a user if he really wants to close an application. If we have a clock or a calculator then it does not matter that much. But if we have a text editor or a drawing application, it does matter. We might accidentally press the Escape key and loose all our modifications.

case WM_KEYDOWN:

    if (wParam == VK_ESCAPE) {

        int ret = MessageBoxW(hwnd, L"Are you sure to quit?", 
                            L"Message", MB_OKCANCEL);
                            
        if (ret == IDOK) {
    
            SendMessage(hwnd, WM_CLOSE, 0, 0);
        }
    }

    break;
If we press a key, the window procedure receives a WM_KEYDOWN message. The wParam parameter has a key code. We can close the window by sending a WM_CLOSE message. The message is sent with the SendMessage() function.

Moving a window

When we move a window on the screen, the window procedure receives the WM_MOVE message. In our example we display the current window position on the screen—we display the coordinates of the top-left corner of the window.

moving.c
#include <windows.h>
#include <wchar.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateLabels(HWND);

HWND hwndSta1;
HWND hwndSta2;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                    PWSTR pCmdLine, int CmdShow) {
    HWND hwnd;
    MSG  msg;

    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Moving";
    wc.hInstance     = hInstance ;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"Moving",
                         WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                         150, 150, 250, 180, 0, 0, hInstance, 0);

    while(GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    wchar_t buf[10];
    RECT rect;

    switch(msg) {
    
      case WM_CREATE:
      
        CreateLabels(hwnd);
        break;

      case WM_MOVE:
      
        GetWindowRect(hwnd, &rect);

        StringCbPrintfW(buf, BUF_LEN, L"%ld", rect.left);  
        SetWindowTextW(hwndSta1, buf);

        StringCbPrintfW(buf, BUF_LEN, L"%ld", rect.top);  
        SetWindowTextW(hwndSta2, buf);

        break;

      case WM_DESTROY:
      
        PostQuitMessage(0);
        break; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CreateLabels(HWND hwnd) {

    CreateWindowW(L"static", L"x: ",
        WS_CHILD | WS_VISIBLE,
        10, 10, 25, 25, 
        hwnd, (HMENU) 1, NULL, NULL);

    hwndSta1 = CreateWindowW(L"static", L"150",
        WS_CHILD | WS_VISIBLE,
        40, 10, 55, 25, 
       hwnd, (HMENU) 2, NULL, NULL);

    CreateWindowW(L"static", L"y: ",
        WS_CHILD | WS_VISIBLE,
        10, 30, 25, 25, 
        hwnd, (HMENU) 3, NULL, NULL);

    hwndSta2 = CreateWindowW(L"static", L"150",
        WS_CHILD | WS_VISIBLE,
        40, 30, 55, 25, 
        hwnd, (HMENU) 4, NULL, NULL);
}
The creation of the static text controls is delegated to the CreateLabels() function.

void CreateLabels(HWND hwnd) {

    CreateWindowW(L"static", L"x: ",
        WS_CHILD | WS_VISIBLE,
        10, 10, 25, 25, 
        hwnd, (HMENU) 1, NULL, NULL);

    hwndSta1 = CreateWindowW(L"static", L"150",
        WS_CHILD | WS_VISIBLE,
        40, 10, 55, 25, 
       hwnd, (HMENU) 2, NULL, NULL);

    CreateWindowW(L"static", L"y: ",
        WS_CHILD | WS_VISIBLE,
        10, 30, 25, 25, 
        hwnd, (HMENU) 3, NULL, NULL);

    hwndSta2 = CreateWindowW(L"static", L"150",
        WS_CHILD | WS_VISIBLE,
        40, 30, 55, 25, 
        hwnd, (HMENU) 4, NULL, NULL);
}
There are four static text controls. Two of them change during the lifetime of the application. So we need only two handles.

case WM_MOVE:

  GetWindowRect(hwnd, &rect);

  StringCbPrintfW(buf, BUF_LEN, L"%ld", rect.left);  
  SetWindowTextW(hwndSta1, buf);

  StringCbPrintfW(buf, BUF_LEN, L"%ld", rect.top);  
  SetWindowTextW(hwndSta2, buf);

  break;
To get the window coordinates, we call the GetWindowRect() function. Since a coordinate is a number, we must convert it to a string. To accomplish this, we use the StringCbPrintfW() function.

Moving a window
Figure: Moving a window
Flashing a window

Sometimes when an important event happens, the title bar or the taskbar button start to flash. The flashing is the change of the title bar from inactive status to active status and vice versa. This is a common feature in Miranda IM when we receive a new message.

flashing.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Flash";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0,IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Flash",
                 WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                 100, 100, 250, 180, 0, 0, hInstance, 0);

    while(GetMessage(&msg, NULL, 0, 0)) {
    
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }

   return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
  
    FLASHWINFO fwi;

    switch(msg)  {
    
      case WM_CREATE:

          CreateWindowW(L"Button", L"Flash",
                  WS_CHILD | WS_VISIBLE,
                  10, 10, 80, 25, 
                  hwnd, (HMENU) 1, NULL, NULL);
          break;

      case WM_COMMAND:

          fwi.cbSize = sizeof(fwi);
          fwi.dwFlags = FLASHW_ALL;
          fwi.dwTimeout = 0;
          fwi.hwnd = hwnd;
          fwi.uCount = 4;

          FlashWindowEx(&fwi);
          break;

      case WM_DESTROY:

          PostQuitMessage(0);
          break; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In order to flash a window, we must do two steps: create and fill a FLASHWINFO structure and call the FlashWindowEx() function.

fwi.dwFlags = FLASHW_ALL;
We have set the FLASHW_ALL flag. This will flash both the title bar and the taskbar button. To flash only the titlebar, we can use the FLASHW_CAPTION tag. To flash the taskbar button, we can use the FLASHW_TRAY flag.

fwi.dwTimeout = 0;
The dwTimeout member is the rate at which the window is to be flashed, in milliseconds. If dwTimeout is zero, the function uses the default cursor blink rate.

fwi.hwnd = hwnd;
fwi.uCount = 4;
Here we set which window to flash and how many times we want to flash it. In our case, we flash the main window four times.

FlashWindowEx(&fwi);
The FlashWindowEx() starts the flashing.

In this part of the Windows API tutorial, we have created some simple UI examples.

;;------------------------------

Windows API menus

In this part of the Windows API tutorial, we create menus. A menu is a group of commands located in a menubar. A menubar contains a list of menus. Menus can contain either menu items or other menus calls submenus. A menu item that carries out a command is called a command item or a command. On Windows, menubar is sometimes called a toplevel menu; menus and submenus are called popup menus. Menu items are usually grouped into some logical groups. These groups are divided by a separator. The separator is a small horizontal line.


 
A simple menu

In the following example, we create a menubar and three menu commands. We also create a separator.

simplemenu.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void AddMenus(HWND);

#define IDM_FILE_NEW 1
#define IDM_FILE_OPEN 2
#define IDM_FILE_QUIT 3

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
                     
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Simple menu";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Simple menu",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 350, 250, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
  switch(msg) {
  
      case WM_CREATE:
      
          AddMenus(hwnd);
          break;

      case WM_COMMAND:
      
          switch(LOWORD(wParam)) {
          
              case IDM_FILE_NEW:
              case IDM_FILE_OPEN:
              
                  MessageBeep(MB_ICONINFORMATION);
                  break;
                  
              case IDM_FILE_QUIT:
              
                  SendMessage(hwnd, WM_CLOSE, 0, 0);
                  break;
           }
           
           break;

      case WM_DESTROY:
      
          PostQuitMessage(0);
          break;
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void AddMenus(HWND hwnd) {

    HMENU hMenubar;
    HMENU hMenu;

    hMenubar = CreateMenu();
    hMenu = CreateMenu();

    AppendMenuW(hMenu, MF_STRING, IDM_FILE_NEW, L"&New");
    AppendMenuW(hMenu, MF_STRING, IDM_FILE_OPEN, L"&Open");
    AppendMenuW(hMenu, MF_SEPARATOR, 0, NULL);
    AppendMenuW(hMenu, MF_STRING, IDM_FILE_QUIT, L"&Quit");

    AppendMenuW(hMenubar, MF_POPUP, (UINT_PTR) hMenu, L"&File");
    SetMenu(hwnd, hMenubar);
}
Two menu items make a short sound. The third terminates the application.

case WM_COMMAND:

    switch(LOWORD(wParam)) {
    
        case IDM_FILE_NEW:
        case IDM_FILE_OPEN:
        
            MessageBeep(MB_ICONINFORMATION);
            break;
            
        case IDM_FILE_QUIT:
        
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
    }
    
    break;
If we select a menu item, the window procedure receives the WM_COMMAND message. The menu item id is in the low order word of the wParam value.

hMenubar = CreateMenu();
hMenu = CreateMenu();
Menubar and menus are created using the CreateMenu() function.

AppendMenuW(hMenu, MF_STRING, IDM_FILE_NEW, L"&New");
AppendMenuW(hMenu, MF_STRING, IDM_FILE_OPEN, L"&Open");
AppendMenuW(hMenu, MF_SEPARATOR, 0, NULL);
AppendMenuW(hMenu, MF_STRING, IDM_FILE_QUIT, L"&Quit");

AppendMenuW(hMenubar, MF_POPUP, (UINT_PTR) hMenu, L"&File");
Menu items and submenus are created using the AppendMenuW() function. What are we going to append, depends on the flag. The MF_STRING appends a label, the MF_SEPARATOR appends a separator and the MF_POPUP appends a menu.

SetMenu(hwnd, hMenubar);
Finally, we set the menubar calling the SetMenu() function.

A menu example
Figure: A simple menu
A popup menu

A popup menu is also called context menu. It is a list of commands that appears under some context. For example, in a Firefox web browser when we right click on a web page, we get a context menu. Here we can reload a page, go back, or view a page source. If we right click on a toolbar, we get another context menu for managing toolbars.

popupmenu.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

#define IDM_FILE_NEW 1
#define IDM_FILE_OPEN 2
#define IDM_FILE_QUIT 3


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Popup menu";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Popup menu",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 350, 250, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    HMENU hMenu;
    POINT point;

    switch(msg) {
  
      case WM_COMMAND:
    
          switch(LOWORD(wParam)) {
        
              case IDM_FILE_NEW:
              case IDM_FILE_OPEN:
            
                  MessageBeep(MB_ICONINFORMATION);
                  break;
                
              case IDM_FILE_QUIT:
            
                  SendMessage(hwnd, WM_CLOSE, 0, 0);
                  break;
          }
        
          break;

      case WM_RBUTTONUP:
     
          point.x = LOWORD(lParam);
          point.y = HIWORD(lParam);
        
          hMenu = CreatePopupMenu();
          ClientToScreen(hwnd, &point);

          AppendMenuW(hMenu, MF_STRING, IDM_FILE_NEW, L"&New");
          AppendMenuW(hMenu, MF_STRING, IDM_FILE_OPEN, L"&Open");
          AppendMenuW(hMenu, MF_SEPARATOR, 0, NULL);
          AppendMenuW(hMenu, MF_STRING, IDM_FILE_QUIT, L"&Quit");
                    
          TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, point.x, point.y, 0, hwnd, NULL);
          DestroyMenu(hMenu);
          break;

      case WM_DESTROY:
     
          PostQuitMessage(0);
          break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
We have an example with a context menu that has three menu items.

case WM_RBUTTONUP:

    point.x = LOWORD(lParam);
    point.y = HIWORD(lParam);
...    
The WM_RBUTTONUP message is posted when the user releases the right mouse button while the cursor is in the client area of a window. The low-order word of the lParam specifies the x coordinate of the cursor. The high-order word specifies the y coordinate of the cursor. The coordinates are relative to the upper-left corner of the client area.

hMenu = CreatePopupMenu();   
The CreatePopupMenu() function creates a popup menu. It returns a handle to the newly created menu. The menu is initially empty.

ClientToScreen(hwnd, &point);   
The ClientToScreen() function converts the client coordinates of a specified point to screen coordinates. We need these coordinates to display the context menu.

AppendMenuW(hMenu, MF_STRING, IDM_FILE_NEW, L"&New");
AppendMenuW(hMenu, MF_STRING, IDM_FILE_OPEN, L"&Open");
AppendMenuW(hMenu, MF_SEPARATOR, 0, NULL);
AppendMenuW(hMenu, MF_STRING, IDM_FILE_QUIT, L"&Quit");   
Three menu items and one separator are created.

TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, point.x, point.y, 0, hwnd, NULL);   
The TrackPopupMenu() function displays a context menu at the specified location and tracks the selection of items on the menu.

DestroyMenu(hMenu);   
In the end, the menu object is destroyed with the DestroyMenu() function. A menu that was not assigned to a window must be explicitly destroyed.

A popup menu
Figure: A popup menu
A check menu item

A check menu item is a menu item that has a check mark before its label. A menu item can be checked or unchecked using the CheckMenuItem() function.

checkmenuitem.c
#include <windows.h>
#include <commctrl.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void AddMenus(HWND);

#define IDM_VIEW_STB 1

HWND ghSb;
HMENU ghMenu;


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
                    
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Check menu item";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Check menu item",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 350, 250, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
   
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    UINT state;

    switch(msg) {
    
      case WM_CREATE:
      
          AddMenus(hwnd);          
          InitCommonControls();

          ghSb = CreateWindowExW(0, STATUSCLASSNAMEW, NULL, 
              WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, hwnd, 
              (HMENU) 1, GetModuleHandle(NULL), NULL);

          break;

      case WM_COMMAND:
          
          switch(LOWORD(wParam)) {
          
              case IDM_VIEW_STB:                                    
                  
                  state = GetMenuState(ghMenu, IDM_VIEW_STB, MF_BYCOMMAND); 

                  if (state == MF_CHECKED) {
                  
                      ShowWindow(ghSb, SW_HIDE);
                      CheckMenuItem(ghMenu, IDM_VIEW_STB, MF_UNCHECKED);  
                  } else {
                  
                      ShowWindow(ghSb, SW_SHOWNA);
                      CheckMenuItem(ghMenu, IDM_VIEW_STB, MF_CHECKED);  
                  }
                  
                  break;
          }
          
          break;

      case WM_SIZE:
      
          SendMessage(ghSb, WM_SIZE, wParam, lParam);          
          break;

      case WM_DESTROY:
      
          PostQuitMessage(0);
          break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}


void AddMenus(HWND hwnd) {

    HMENU hMenubar;

    hMenubar = CreateMenu();
    ghMenu = CreateMenu();

    AppendMenuW(ghMenu, MF_STRING, IDM_VIEW_STB, L"&Statusbar");
    CheckMenuItem(ghMenu, IDM_VIEW_STB, MF_CHECKED);  

    AppendMenuW(hMenubar, MF_POPUP, (UINT_PTR) ghMenu, L"&View");
  
    SetMenu(hwnd, hMenubar);
}
In the example we have a View menu with one menu item. This menu item will show or hide a statusbar. When the statusbar is visible, the menu item is checked.

#define IDM_VIEW_STB 1
This is an id for the menu item that will show or hide the statusbar.

InitCommonControls();
A statusbar is a common control. It must be initialized with the InitCommonControls() function.

ghSb = CreateWindowExW(0, STATUSCLASSNAMEW, NULL, 
    WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, hwnd, 
    (HMENU) 1, GetModuleHandle(NULL), NULL);  
This code line creates a statusbar control.

state = GetMenuState(ghMenu, IDM_VIEW_STB, MF_BYCOMMAND); 
We get the state of the statusbar menu item with the GetMenuState() function.

if (state == MF_CHECKED) {

    ShowWindow(ghSb, SW_HIDE);
    CheckMenuItem(ghMenu, IDM_VIEW_STB, MF_UNCHECKED);  
} else {

    ShowWindow(ghSb, SW_SHOWNA);
    CheckMenuItem(ghMenu, IDM_VIEW_STB, MF_CHECKED);  
}
Depending on its state, we show or hide the statusbar control using the ShowWindow() function. The menu item is checked or unchecked accordingly with the CheckMenuItem() function.

case WM_SIZE:

    SendMessage(ghSb, WM_SIZE, wParam, lParam);          
    break;
We resize the statusbar to fit the window after the window is being resized.

A check menu item
Figure: A check menu item
A radio menu item

Radio menu items enable to select from a mutually exclusive list of options. Radio menu items are managed with the CheckMenuRadioItem() function.

radiomenuitem.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void AddMenus(HWND);

#define IDM_MODE_MAP 1
#define IDM_MODE_SAT 2
#define IDM_MODE_TRA 3
#define IDM_MODE_STR 4

HMENU hMenu;


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
                     
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Radio menu item";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Radio menu item",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 350, 250, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
  switch(msg) {
  
      case WM_CREATE:
      
          AddMenus(hwnd);
          break;

      case WM_COMMAND:
      
          switch(LOWORD(wParam)) {
          
              case IDM_MODE_MAP:
                  CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
                      IDM_MODE_MAP, MF_BYCOMMAND);
                  MessageBeep(MB_ICONERROR);
                  break;

              case IDM_MODE_SAT:
                  CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
                      IDM_MODE_SAT, MF_BYCOMMAND);
                  MessageBeep(0xFFFFFFFF);
                  break;

              case IDM_MODE_TRA:
                  CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
                      IDM_MODE_TRA, MF_BYCOMMAND);
                  MessageBeep(MB_ICONWARNING);
                  break;

              case IDM_MODE_STR:
                  CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
                      IDM_MODE_STR, MF_BYCOMMAND);
              
                  MessageBeep(MB_ICONINFORMATION);
                  break;
           }
           
           break;

      case WM_DESTROY:
      
          PostQuitMessage(0);
          break;
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void AddMenus(HWND hwnd) {

    HMENU hMenubar;

    hMenubar = CreateMenu();
    hMenu = CreateMenu();

    AppendMenuW(hMenu, MF_STRING, IDM_MODE_MAP, L"&Map");
    AppendMenuW(hMenu, MF_STRING, IDM_MODE_SAT, L"&Satellite");
    AppendMenuW(hMenu, MF_STRING, IDM_MODE_TRA, L"&Traffic");
    AppendMenuW(hMenu, MF_STRING, IDM_MODE_STR, L"Street &view");

    CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
        IDM_MODE_MAP, MF_BYCOMMAND);

    AppendMenuW(hMenubar, MF_POPUP, (UINT_PTR) hMenu, L"&Map mode");
    SetMenu(hwnd, hMenubar);
}
In the example, we have four radio menu items; only one of them can be selected at a time. Each radio menu item beeps a different sound.

#define IDM_MODE_MAP 1
#define IDM_MODE_SAT 2
#define IDM_MODE_TRA 3
#define IDM_MODE_STR 4
These are Ids of radio menu items.

case IDM_MODE_MAP:
    CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
        IDM_MODE_MAP, MF_BYCOMMAND);
    MessageBeep(MB_ICONERROR);
    break;
The CheckMenuRadioItem() checks a specified menu item and makes it a radio item. In addition, it clears all other menu items in the associated group of menu items. The function's first parameter is a handle to the menu that contains the group of menu items. The last parameter indicates the meaning of the previous three parameters; when MF_BYCOMMAND is specified, these parameters are Ids of menu items. The second parameter is the Id of the first menu item in the group, the third parameter is the Id of the last menu item in the group. The fourth parameter is the menu identifier to be checked.

...
AppendMenuW(hMenu, MF_STRING, IDM_MODE_STR, L"Street &view");

CheckMenuRadioItem(hMenu, IDM_MODE_MAP, IDM_MODE_STR, 
    IDM_MODE_MAP, MF_BYCOMMAND);

AppendMenuW(hMenubar, MF_POPUP, (UINT_PTR) hMenu, L"&Map mode");
...
At the beginning, the first radio item is selected.

A radio menu item
Figure: A radio menu item
Submenu

A submenu is a menu located inside another menu.

submenu.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void AddMenus(HWND);

#define IDM_FILE_NEW 1
#define IDM_FILE_IMPORT 2

#define IDM_IMPORT_MAIL 11


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
                     
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Submenu";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Submenu",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 350, 250, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
  switch(msg) {
  
      case WM_CREATE:
      
          AddMenus(hwnd);
          break;

      case WM_COMMAND:
      
          switch(LOWORD(wParam)) {
          
              case IDM_FILE_NEW:
                  MessageBoxW(NULL, L"New file selected", 
                        L"Information", MB_OK);
                  break;

              case IDM_IMPORT_MAIL:
                  MessageBoxW(NULL, L"Import mail selected", 
                        L"Information", MB_OK);
           }
           
           break;

      case WM_DESTROY:
      
          PostQuitMessage(0);
          break;
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void AddMenus(HWND hwnd) {
  
    HMENU hMenubar = CreateMenu();
    HMENU hMenu = CreateMenu();
    HMENU hSubMenu = CreatePopupMenu();

    AppendMenuW(hMenu, MF_STRING, IDM_FILE_NEW, L"&New");

    AppendMenuW(hMenu, MF_STRING | MF_POPUP, (UINT_PTR) hSubMenu, L"&Import");
    AppendMenuW(hSubMenu, MF_STRING, IDM_IMPORT_MAIL, L"Import &mail");

    AppendMenuW(hMenubar, MF_POPUP, (UINT_PTR) hMenu, L"&File");
    SetMenu(hwnd, hMenubar);
}
In the example, we have two menu items; one is located in the File menu and the other one in the File's Import submenu. Selecting each menu item causes a message box to be displayed.

case IDM_IMPORT_MAIL:
    MessageBoxW(NULL, L"Import mail selected", 
          L"Information", MB_OK);
When we select the Import mail submenu item, a message box is shown with the "Import mail selected" text.

HMENU hSubMenu = CreatePopupMenu();
A submenu is created with the CreatePopupMenu() function.

AppendMenuW(hMenu, MF_STRING | MF_POPUP, (UINT_PTR) hSubMenu, L"&Import");
With the AppendMenuW() function, we add a submenu to the File menu. The MF_POPUP flag is used both for popup menus and submenus.

AppendMenuW(hSubMenu, MF_STRING, IDM_IMPORT_MAIL, L"Import &mail");
A menu item is normally added to the submenu with the AppendMenuW() function.

Submenu
Figure: Submenu
In this part of the Windows API tutorial, we have covered menus.

;; -----------------

Windows API dialogs

Dialog windows or dialogs are an indispensable part of most modern GUI applications. A dialog is defined as a conversation between two or more persons. In a computer application a dialog is a window which is used to "talk" to the application. A dialog is used to input data, modify data, change the application settings etc. Dialogs are important means of communication between a user and a computer program.


 
Modeless Dialog

Modeless dialogs does not restrict you to working with a particular window. A user can switch between a dialog box and other windows of a program. A typical modeless dialog is a Find and Replace dialog or a floating toolbar.

#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);

void CreateDialogBox(HWND);
void RegisterDialogClass(HWND);

HINSTANCE ghInstance;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR pCmdLine, int nCmdShow) {

  MSG  msg;    
  HWND hwnd;

  WNDCLASSW wc = {0};

  wc.lpszClassName = L"Window";
  wc.hInstance     = hInstance;
  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
  wc.lpfnWndProc   = WndProc;
  
  RegisterClassW(&wc);
  hwnd = CreateWindowW(wc.lpszClassName, L"Window",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100, 100, 250, 150, NULL, NULL, hInstance, NULL);  

  ghInstance = hInstance;

  while( GetMessage(&msg, NULL, 0, 0)) {
    DispatchMessage(&msg);
  }
  
  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {

  switch(msg) {
  
      case WM_CREATE:
          RegisterDialogClass(hwnd);
          CreateWindowW(L"button", L"Show dialog",    
              WS_VISIBLE | WS_CHILD ,
              20, 50, 95, 25, hwnd, (HMENU) 1, NULL, NULL);  
          break;

      case WM_COMMAND:
          CreateDialogBox(hwnd);
          break;

      case WM_DESTROY:
      {
          PostQuitMessage(0);
          return 0;
      }
  }
  return DefWindowProcW(hwnd, msg, wParam, lParam);
}

LRESULT CALLBACK DialogProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  switch(msg) {
  
    case WM_CREATE:
        CreateWindowW(L"button", L"Ok",    
          WS_VISIBLE | WS_CHILD ,
          50, 50, 80, 25, hwnd, (HMENU) 1, NULL, NULL);  
    break;

    case WM_COMMAND:
        DestroyWindow(hwnd);
    break;

    case WM_CLOSE:
        DestroyWindow(hwnd);
        break;

  }
  
  return (DefWindowProcW(hwnd, msg, wParam, lParam));
}

void RegisterDialogClass(HWND hwnd) {

  WNDCLASSEXW wc = {0};
  wc.cbSize           = sizeof(WNDCLASSEXW);
  wc.lpfnWndProc      = (WNDPROC) DialogProc;
  wc.hInstance        = ghInstance;
  wc.hbrBackground    = GetSysColorBrush(COLOR_3DFACE);
  wc.lpszClassName    = L"DialogClass";
  RegisterClassExW(&wc);

}

void CreateDialogBox(HWND hwnd) {

  CreateWindowExW(WS_EX_DLGMODALFRAME | WS_EX_TOPMOST,  L"DialogClass", L"Dialog Box", 
        WS_VISIBLE | WS_SYSMENU | WS_CAPTION , 100, 100, 200, 150, 
        NULL, NULL, ghInstance,  NULL);
}
A dialog is only a special kind of a window. It is created as a normal window with some specific flags.

CreateWindowExW(WS_EX_DLGMODALFRAME | WS_EX_TOPMOST,  L"DialogClass", L"Dialog Box", 
    WS_VISIBLE | WS_SYSMENU | WS_CAPTION , 100, 100, 200, 150, 
    NULL, NULL, ghInstance,  NULL);
The dialog is created with a combination of regular flags WS_VISIBLE | WS_SYSMENU | WS_CAPTION and extended flags WS_EX_DLGMODALFRAME | WS_EX_TOPMOST.

Modeless dialog
Figure: Modeless dialog
Common Dialog Boxes

These are dialogs for performing common tasks. Opening and saving files, printing documents, choosing colour etc. Common dialog boxes save programmers a lot of work. They help promote standards in applications.

Colour dialog box

This is a common dialog for choosing colour.

#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK PanelProc(HWND, UINT, WPARAM, LPARAM);

void RegisterPanel(void);
COLORREF ShowColorDialog(HWND);

COLORREF gColor = RGB(255, 255, 255);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR pCmdLine, int nCmdShow) {
    
  MSG  msg ;    
  WNDCLASSW wc = {0};
  wc.lpszClassName = L"Color dialog box";
  wc.hInstance     = hInstance;
  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
  wc.lpfnWndProc   = WndProc;
  
  RegisterClassW(&wc);
  CreateWindowW( wc.lpszClassName, L"Color dialog box",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                150, 150, 250, 200, 0, 0, hInstance, 0);  

  while( GetMessage(&msg, NULL, 0, 0)) {
    DispatchMessage(&msg);
  }
  
  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {

  static HWND hwndPanel;

  switch(msg) {
  
    case WM_CREATE:
    {
        CreateWindowW(L"button", L"Color",
           WS_VISIBLE | WS_CHILD ,
           20, 30, 80, 25,
           hwnd, (HMENU) 1, NULL, NULL);

        RegisterPanel();
        hwndPanel = CreateWindowW(L"Panel", NULL, 
                    WS_CHILD | WS_VISIBLE,
                    130, 30, 80, 80, hwnd, (HMENU) 2, NULL, NULL);   
        break;
    }

    case WM_COMMAND:
    {
        gColor = ShowColorDialog(hwnd);
        InvalidateRect(hwndPanel, NULL, TRUE);    
        break;
    }

    case WM_DESTROY:
    {
        PostQuitMessage(0);
        break;
    }
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}

LRESULT CALLBACK PanelProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {

  HDC hdc;
  PAINTSTRUCT ps; 
  RECT rect;

  switch(msg) {
  
    case WM_PAINT:
    {
        GetClientRect(hwnd, &rect);
        hdc = BeginPaint(hwnd, &ps);
        SetBkColor(hdc, gColor);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, "", 0, NULL);
        EndPaint(hwnd, &ps);
        break;
    }
  }
  
  return DefWindowProc(hwnd, msg, wParam, lParam);
}


COLORREF ShowColorDialog(HWND hwnd) {

  CHOOSECOLOR cc;
  static COLORREF crCustClr[16];

  ZeroMemory(&cc, sizeof(cc));
  cc.lStructSize = sizeof(cc);
  cc.hwndOwner = hwnd;
  cc.lpCustColors = (LPDWORD) crCustClr;
  cc.rgbResult = RGB(0, 255, 0);
  cc.Flags = CC_FULLOPEN | CC_RGBINIT;
  ChooseColor(&cc);

  return cc.rgbResult;
}

void RegisterPanel(void) {

  WNDCLASSW rwc = {0};
  rwc.lpszClassName = L"Panel";
  rwc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
  rwc.lpfnWndProc   = PanelProc;
  RegisterClassW(&rwc);
}
In our example, we have a button control and a child window. The colour of the child window is white at the beginning. We can change the colour of the child window, by pressing on the button and choosing a custom colour value.

COLORREF gColor = RGB(255, 255, 255);
We define a global colour value; it is white by default.

gColor = ShowColorDialog(hwnd);
The color dialog box is shown in the ShowColorDialog() user function. The function returns the chosen colour value.

CHOOSECOLOR cc; 
To create a color dialog box, we must define and fill a CHOOSECOLOR structure.

cc.rgbResult = RGB(0, 255, 0);
cc.Flags = CC_FULLOPEN | CC_RGBINIT;
If we provide the CC_RGBINIT then the rgbResult member is the initial selected color when the dialog is displayed. If the user clicks the OK button, the rgbResult specifies the user's colour selection.

ChooseColor(&cc);
The color dialog box is displayed.

gColor = ShowColorDialog(hwnd);
InvalidateRect(hwndPanel, NULL, TRUE); 
After we obtain the colour value, we call the InvalidateRect() function. This function will send WM_PAINT message to our child window.

SetBkColor(hdc, gColor);
ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, "", 0, NULL);
In the panel procedure, we change the background colour of the child window. Besides displaying text on the window, the ExtTextOut() function can also change a window's background color. We won't display any text, we only change the background colour. If we provide the ETO_OPAQUE flag, the ExtTextOut() function will use the color, specified by the SetBkColor() function.

Color dialog box
Figure: Color dialog box
Openfile dialog box

This is a common dialog for opening files. Do not use UNICODE to compile this example.

#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateMenubar(HWND);
void OpenDialog(HWND);
void LoadFile(LPSTR);

#define IDM_FILE_NEW 1
HWND ghwndEdit;


int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, int nCmdShow) {
    
  MSG  msg ;    
  WNDCLASS wc = {0};
  wc.lpszClassName = TEXT( "Opendialog" );
  wc.hInstance     = hInstance ;
  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
  wc.lpfnWndProc   = WndProc ;
  wc.hCursor       = LoadCursor(0, IDC_ARROW);

  
  RegisterClass(&wc);
  CreateWindow( wc.lpszClassName, TEXT("Opendialog"),
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                150, 150, 265, 200, 0, 0, hInstance, 0);  

  while( GetMessage(&msg, NULL, 0, 0)) {
    DispatchMessage(&msg);
  }
  
  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
   
  switch(msg) {
  
      case WM_CREATE:
          ghwndEdit = CreateWindowEx(WS_EX_RIGHTSCROLLBAR, TEXT("edit"), NULL,
                    WS_VISIBLE | WS_CHILD | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE,
                    0, 0, 260, 180,
                    hwnd, (HMENU) 1, NULL, NULL);


          CreateMenubar(hwnd);
          break;

      case WM_SIZE:
          SetWindowPos(ghwndEdit, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam),
             SWP_NOMOVE | SWP_NOZORDER);
          break;

      case WM_COMMAND:
          if (wParam==IDM_FILE_NEW) {
              OpenDialog(hwnd);
          }
          break;

      case WM_DESTROY:
          PostQuitMessage(0);
          break;
  }
  
  return DefWindowProc(hwnd, msg, wParam, lParam);
}

void CreateMenubar(HWND hwnd) {

  HMENU hMenubar;
  HMENU hMenu;

  hMenubar = CreateMenu();
  hMenu = CreateMenu();
  AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hMenu, TEXT("&File"));
  AppendMenu(hMenu, MF_STRING, IDM_FILE_NEW, TEXT("&Open"));
  SetMenu(hwnd, hMenubar);
}

void OpenDialog(HWND hwnd) {

  OPENFILENAME ofn;
  TCHAR szFile[MAX_PATH];

  ZeroMemory(&ofn, sizeof(ofn));
  ofn.lStructSize = sizeof(ofn);
  ofn.lpstrFile = szFile;
  ofn.lpstrFile[0] = '\0';
  ofn.hwndOwner = hwnd;
  ofn.nMaxFile = sizeof(szFile);
  ofn.lpstrFilter = TEXT("All files(*.*)\0*.*\0");
  ofn.nFilterIndex = 1;
  ofn.lpstrInitialDir = NULL;
  ofn.lpstrFileTitle = NULL;
  ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

  if(GetOpenFileName(&ofn))
      LoadFile(ofn.lpstrFile);
}

void LoadFile(LPSTR file) {

  HANDLE hFile;
  DWORD dwSize;
  DWORD dw;

  LPBYTE lpBuffer = NULL;

  hFile = CreateFile(file, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
  dwSize = GetFileSize(hFile, NULL);
  lpBuffer = (LPBYTE) HeapAlloc(GetProcessHeap(), 
      HEAP_GENERATE_EXCEPTIONS, dwSize + 1);
  ReadFile(hFile, (LPWSTR)lpBuffer, dwSize, &dw, NULL);
  CloseHandle(hFile);
  lpBuffer[dwSize] = 0;
  SetWindowText(ghwndEdit, (LPSTR) lpBuffer);
  HeapFree(GetProcessHeap(), 0, lpBuffer);
}
In this example, we create a window with a multiline edit control.

To create an openfile dialog box, we create and fill the OPENFILENAME structure.

ofn.lpstrFile = szFile;
If the OpenFileName() function returns TRUE, the name of the selected file is in the lpstrFile member.

ofn.lpstrFilter = TEXT("All files(*.*)\0*.*\0");
This defines the file filter. In our example, the dialog shows all file types.

ofn.nFilterIndex = 1;
Specifies the index of the currently selected filter in the File Types combo box control.

if(GetOpenFileName(&ofn))
    LoadFile(ofn.lpstrFile);
We call the GetOpenFileName() function to show the Openfile dialog box. If we click on the Open button, the function returns TRUE and we call the user defined LoadFile() function.

Inside the LoadFile() function, we read the file and put the contents of the file into the edit control. We create a file handle. Than we find out the file size. Allocate dynamic memory for the contents of the file. Read the contents into the memory and put them into the edit control. To put the contents into the edit control, we call the SetWindowText() function. We must not forget to close the file handle and free the dynamic memory.

Openfile dialog box
Figure: Openfile dialog box
In this part of the Windows API tutorial, we worked with dialogs.

;; ---------------------------

Windows API controls I

Controls are basic building blocks of a Windows application. (Controls are called widgets in UNIX.) This part of the Windows API tutorial covers a static control, a button, a check box, and an edit box.


 
Controls are windows too. They are created using the CreateWindowW() or CreateWindowExW() functions. These functions take a window class name as their first and second parameter respectively. Controls have their specific predefined window class names; therefore, we do not call the RegisterClassW() or RegisterClassExW() when we create controls.

Static control

Static control displays text and graphics. The static control cannot be selected. It also cannot have keyboard focus.

Static text

In the first example, we create a static text control.

static_text.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Static Control";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

  
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Criminal",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 330, 270, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
  
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    static wchar_t *lyrics =  L"I know you told me I should stay away\n\
I know you said he's just a dog astray\n\
He is a bad boy with a tainted heart\n\
And even I know this ain't smart\n\
\n\
But mama, I'm in love with a criminal\n\
And this type of love isn't rational, it's physical\n\
Mama, please don't cry, I will be alright\n\
All reason aside, I just can't deny, love the guy\n\
";

    switch(msg) {

        case WM_CREATE:
      
            CreateWindowW(L"Static", lyrics, 
                WS_CHILD | WS_VISIBLE | SS_LEFT,
                20, 20, 300, 230, 
                hwnd, (HMENU) 1, NULL, NULL);
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
The example shows lyrics of a song on a window.

CreateWindowW(L"Static", lyrics, 
    WS_CHILD | WS_VISIBLE | SS_LEFT,
    20, 20, 300, 230,
    hwnd, (HMENU) 1, NULL, NULL);
break;
The static control is created with the L"Static" class. The text is aligned to the left with the SS_LEFT style.

Static text control
Static text control
Static image

The second example creates a static image control.

static_image.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void LoadMyImage(void);

HBITMAP hBitmap;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Static image";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0,IDC_ARROW);

  
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Static image",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 330, 270, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    HWND hsti;

    switch(msg) {

        case WM_CREATE:
    
            LoadMyImage();
            hsti = CreateWindowW(L"Static", L"", 
                WS_CHILD | WS_VISIBLE | SS_BITMAP,
                5, 5, 300, 300, hwnd, (HMENU) 1, NULL, NULL);

            SendMessage(hsti, STM_SETIMAGE,
                (WPARAM) IMAGE_BITMAP, (LPARAM) hBitmap); 
            break;

        case WM_DESTROY:

            DeleteObject(hBitmap);
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void LoadMyImage(void) {

    hBitmap = LoadImageW(NULL, L"C:\\prog\\slovakia.bmp", IMAGE_BITMAP,
        0, 0, LR_LOADFROMFILE);
}
The example shows a BMP image on the window.

hsti = CreateWindowW(L"Static", L"", 
        WS_CHILD | WS_VISIBLE | SS_BITMAP,
        5, 5, 300, 300, hwnd, (HMENU) 1, NULL, NULL);
The SS_BITMAP constant makes the static control display a bitmap.

SendMessage(hsti, STM_SETIMAGE,
        (WPARAM) IMAGE_BITMAP, (LPARAM) hBitmap); 
The STM_SETIMAGE message is sent to associate a new image with a static control.

void LoadMyImage(void) {

    hBitmap = LoadImageW(NULL, L"C:\\prog\\slovakia.bmp", IMAGE_BITMAP,
        0, 0, LR_LOADFROMFILE);
}
The LoadImageW() function loads a bitmap from the filesystem. If the function succeeds, the return value is the handle of the newly loaded image.

Static image control
Static image control
Button

Button is a simple control with a text label. It is used to trigger an action. When we click on a button, it sends a WM_COMMAND message to its parent window. The low-order word of the wParam parameter contains the control identifier.

button.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

#define ID_BEEP 1
#define ID_QUIT 2

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Buttons";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Buttons",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  150, 150, 300, 200, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {

        case WM_CREATE:

            CreateWindowW(L"Button", L"Beep",
                WS_VISIBLE | WS_CHILD ,
                20, 50, 80, 25, hwnd, (HMENU) ID_BEEP, NULL, NULL);

            CreateWindowW(L"Button", L"Quit",
                WS_VISIBLE | WS_CHILD ,
                120, 50, 80, 25, hwnd, (HMENU) ID_QUIT, NULL, NULL);
            break;

        case WM_COMMAND:

            if (LOWORD(wParam) == ID_BEEP) {
            
                MessageBeep(MB_OK);
            }

            if (LOWORD(wParam) == ID_QUIT) {
            
                PostQuitMessage(0);
            }

            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example we have created two buttons. One button will beep. The other one will close the window.

CreateWindowW(L"Button", L"Beep",
    WS_VISIBLE | WS_CHILD ,
    20, 50, 80, 25, hwnd, (HMENU) ID_BEEP, NULL, NULL);
The button control is created with the L"Button" class.

case WM_COMMAND:

    if (LOWORD(wParam) == ID_BEEP) {
    
        MessageBeep(MB_OK);
    }

    if (LOWORD(wParam) == ID_QUIT) {
    
        PostQuitMessage(0);
    }

    break;
The control's ID is in the LOWORD of the wParam. Depending on the ID, we call the MessageBeep() function or the PostQuitMessage() function.

Button controls
Button controls
Check box

Check box control is a box that you can click to turn an option on or off.

checkbox.c
#include <windows.h>
#include <stdbool.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {
                    
    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Check Box";
    wc.hInstance     = hInstance ;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Check Box",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  150, 150, 230, 150, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    bool checked = true;

    switch(msg) {
  
        case WM_CREATE:

            CreateWindowW(L"button", L"Show Title",
                WS_VISIBLE | WS_CHILD | BS_CHECKBOX,
                20, 20, 185, 35, hwnd, (HMENU) 1, 
                NULL, NULL);

            CheckDlgButton(hwnd, 1, BST_CHECKED);
            break;

        case WM_COMMAND:

            checked = IsDlgButtonChecked(hwnd, 1);

            if (checked) {

                CheckDlgButton(hwnd, 1, BST_UNCHECKED);
                SetWindowTextW(hwnd, L"");

            } else {

               CheckDlgButton(hwnd, 1, BST_CHECKED);
               SetWindowTextW(hwnd, L"Check Box");
            }
      
            break;
 
       case WM_DESTROY:

            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example, we show or hide the window title depending on the state of the check box.

CreateWindowW(L"button", L"Show Title",
    WS_VISIBLE | WS_CHILD | BS_CHECKBOX,
    20, 20, 185, 35, hwnd, (HMENU) 1, 
    NULL, NULL);
Check box is a special kind of a button. It is created with the BS_CHECKBOX flag.

checked = IsDlgButtonChecked(hwnd, 1);
We determine the state of the check box using the IsDlgButtonChecked() function.

CheckDlgButton(hwnd, 1, BST_UNCHECKED);
We check and uncheck the check box using the CheckDlgButton() function.

SetWindowTextW(hwnd, L"");
The SetWindowTextW() function sets the title of the window.

Checkbox control
Checkbox control
Edit control

Edit control is a rectangular child window used to enter and edit text. It can be single line or multiline.

edit.c
#include <windows.h>

#define ID_EDIT 1
#define ID_BUTTON 2

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Edit control";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Edit control",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  220, 220, 280, 200, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
    
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    static HWND hwndEdit;
    HWND hwndButton;

    switch(msg) {

        case WM_CREATE:

            hwndEdit = CreateWindowW(L"Edit", NULL, 
                WS_CHILD | WS_VISIBLE | WS_BORDER,
                50, 50, 150, 20, hwnd, (HMENU) ID_EDIT,
                NULL, NULL);

            hwndButton = CreateWindowW(L"button", L"Set title",
                WS_VISIBLE | WS_CHILD, 50, 100, 80, 25,
                hwnd, (HMENU) ID_BUTTON, NULL, NULL);

            break;

        case WM_COMMAND:	

            if (HIWORD(wParam) == BN_CLICKED) {

                int len = GetWindowTextLengthW(hwndEdit) + 1;
                wchar_t text[len];

                GetWindowTextW(hwndEdit, text, len);
                SetWindowTextW(hwnd, text);
            }

            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example, we have an edit control and a button. We can put some text into the edit control. If we click on the button, the entered text will be displayed in the titlebar of the main window.

hwndEdit = CreateWindowW(L"Edit", NULL, 
    WS_CHILD | WS_VISIBLE | WS_BORDER,
    50, 50, 150, 20, hwnd, (HMENU) ID_EDIT,
    NULL, NULL);
The edit control is created with the L"Edit" window class. The WS_BORDER window style creates a thin-line border around the control.

if (HIWORD(wParam) == BN_CLICKED) {

   int len = GetWindowTextLengthW(hwndEdit) + 1;
   wchar_t text[len];

   GetWindowTextW(hwndEdit, text, len);
   SetWindowTextW(hwnd, text);
}
The GetWindowTextLengthW() returns the length of the entered text. Notice that we add 1 to the length. This is to include the zero terminator. Try to omit it and see what happens. The GetWindowTextW() receives the text from the edit control. The function's first parameter is the handle to the window or control containing the text. The SetWindowTextW() sets the text for the window. In this context, it is the title of the main window.

Edit control
Figure: Edit control
In this part of the Windows API tutorial, we have covered four basic Windows controls.

;; ----------------------------

Windows API controls II

We continue with Windows controls. We will show how to use a Trackbar, a Tooltip, and a Month calendar control.


 
Trackbar

A trackbar is a window that contains a slider and optional tick marks. We move the slider using the mouse or keyboard. A trackbar is used to select discrete values from a range of consecutive values. This control is called a slider on other platforms.

trackbar.c
#include <windows.h>
#include <commctrl.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateControls(HWND hwnd);
void UpdateLabel(void);

HWND hTrack;
HWND hlbl;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
  PWSTR lpCmdLine, int nCmdShow) {
  
    HWND hwnd;
    MSG  msg ;

    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Trackbar";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0,IDC_ARROW);
  
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"Trackbar", 
        WS_OVERLAPPEDWINDOW | WS_VISIBLE, 100, 100, 350, 180, 0, 0, hInstance, 0);
  
    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
  WPARAM wParam, LPARAM lParam) {
  
  switch(msg) {
  
     case WM_CREATE:
       CreateControls(hwnd);
       break;

     case WM_HSCROLL:
       UpdateLabel();
       break;

     case WM_DESTROY:
       PostQuitMessage(0);
       break; 
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CreateControls(HWND hwnd) {

    HWND hLeftLabel = CreateWindowW(L"Static", L"0", 
        WS_CHILD | WS_VISIBLE, 0, 0, 10, 30, hwnd, (HMENU)1, NULL, NULL);

    HWND hRightLabel = CreateWindowW(L"Static", L"100", 
        WS_CHILD | WS_VISIBLE, 0, 0, 30, 30, hwnd, (HMENU)2, NULL, NULL);

    hlbl = CreateWindowW(L"Static", L"0", WS_CHILD | WS_VISIBLE, 
        270, 20, 30, 30, hwnd, (HMENU)3, NULL, NULL);

    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx(&icex); 

    hTrack = CreateWindowW(TRACKBAR_CLASSW, L"Trackbar Control",
        WS_CHILD | WS_VISIBLE | TBS_AUTOTICKS,
        20, 20, 170, 30, hwnd, (HMENU) 3, NULL, NULL);

    SendMessageW(hTrack, TBM_SETRANGE,  TRUE, MAKELONG(0, 100)); 
    SendMessageW(hTrack, TBM_SETPAGESIZE, 0,  10); 
    SendMessageW(hTrack, TBM_SETTICFREQ, 10, 0); 
    SendMessageW(hTrack, TBM_SETPOS, FALSE, 0); 
    SendMessageW(hTrack, TBM_SETBUDDY, TRUE, (LPARAM) hLeftLabel); 
    SendMessageW(hTrack, TBM_SETBUDDY, FALSE, (LPARAM) hRightLabel); 
}

void UpdateLabel(void) {

    LRESULT pos = SendMessageW(hTrack, TBM_GETPOS, 0, 0);
    wchar_t buf[4];
    wsprintfW(buf, L"%ld", pos);

    SetWindowTextW(hlbl, buf);
}
In our example we display a Trackbar control with three static text controls. Two of them are attached to the left and to the right of the trackbar. They are called buddies. By dragging the slider, we change the text of the third static control.

HWND hLeftLabel = CreateWindowW(L"Static", L"0", 
    WS_CHILD | WS_VISIBLE, 0, 0, 10, 30, hwnd, (HMENU)1, NULL, NULL);

HWND hRightLabel = CreateWindowW(L"Static", L"100", 
    WS_CHILD | WS_VISIBLE, 0, 0, 30, 30, hwnd, (HMENU)2, NULL, NULL);

hlbl = CreateWindowW(L"Static", L"0", WS_CHILD | WS_VISIBLE, 
    270, 20, 30, 30, hwnd, (HMENU)3, NULL, NULL);
Three static controls are created. Two controls will display the minimum and maximum value of the Trackbar control. The last one will display the currently selected value.

INITCOMMONCONTROLSEX icex;

icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
icex.dwICC  = ICC_LISTVIEW_CLASSES;
InitCommonControlsEx(&icex); 
If we want to use one of the common controls, we need to load the common control DLL (comctl32.dll) and register specific common control classes from the DLL. The InitCommonControlsEx() must call this function before creating a common control.

hTrack = CreateWindowW(TRACKBAR_CLASSW, L"Trackbar Control",
    WS_CHILD | WS_VISIBLE | TBS_AUTOTICKS,
    20, 20, 170, 30, hwnd, (HMENU) 3, NULL, NULL);
The TRACKBAR_CLASSW is used to create a trackbar control. The TBS_AUTOTICKS style creates a tick mark for each increment in its range of values.

SendMessageW(hTrack, TBM_SETRANGE,  TRUE, MAKELONG(0, 100)); 
SendMessageW(hTrack, TBM_SETPAGESIZE, 0,  10); 
SendMessageW(hTrack, TBM_SETTICFREQ, 10, 0); 
SendMessageW(hTrack, TBM_SETPOS, FALSE, 0); 
We are not yet finished with the Trackbar control. We send four messages to the control. We send a TBM_SETRANGE to set the trackbar range. To set the page size, we send the TBM_SETPAGESIZE message. To set the tick frequency, we send the TBM_SETTICFREQ message. To set the current slider position we send the TBM_SETPOS.

SendMessageW(hTrack, TBM_SETBUDDY, TRUE, (LPARAM) hLeftLabel); 
SendMessageW(hTrack, TBM_SETBUDDY, FALSE, (LPARAM) hRightLabel);  
We set the Trackbar buddies by sending the TBM_SETBUDDY message. The third parameter will decide, whether the buddy is located to the left (TRUE) or to the right (FALSE) of the control.

case WM_HSCROLL:
  UpdateLabel();
  break;
When we move the Trackbar slider, the window procedure receives the WM_HSCROLL message. (In case of a horizontal trackbar.)

void UpdateLabel(void) {

    LRESULT pos = SendMessageW(hTrack, TBM_GETPOS, 0, 0);
    wchar_t buf[4];
    wsprintfW(buf, L"%ld", pos);

    SetWindowTextW(hlbl, buf);
}
In the UpdateLabel() function, we we get the current slider position by sending the TMB_GETPOS message. The received value is converted to text using the wsprintfW() function. Finally, the text of the static control is set with the SetWindowTextW() function.

Trackbar
Figure: Trackbar
A tooltip

A tooltip is a common graphical user element. Tooltip is hidden most of the time. It is a small box that appears near an GUI object when a mouse pointer passes over it. It displays a brief message explaining the object. Tooltips are part of the help system of an application.

tooltip.c
#include <windows.h>
#include <commctrl.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateMyTooltip(HWND);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
            LPSTR lpCmdLine, int nCmdShow) {
    MSG  msg;    
    WNDCLASS wc = {0};
    wc.lpszClassName = "Tooltip";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClass(&wc);
    CreateWindow(wc.lpszClassName, "Tooltip",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100, 100, 200, 150, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
  
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
  
    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {

    switch(msg) {
  
      case WM_CREATE:
          CreateMyTooltip(hwnd);
          break;

      case WM_DESTROY:
          PostQuitMessage(0);
          break;
    }
  
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

void CreateMyTooltip(HWND hwnd) {

    INITCOMMONCONTROLSEX iccex; 
    HWND hwndTT;                

    TOOLINFO ti;
    char tooltip[30] = "A main window";
    RECT rect;                 
  
    iccex.dwICC = ICC_WIN95_CLASSES;
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    InitCommonControlsEx(&iccex);

    hwndTT = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,		
        0, 0, 0, 0, hwnd, NULL, NULL, NULL );

    SetWindowPos(hwndTT, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
   
    GetClientRect(hwnd, &rect);

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_SUBCLASS;
    ti.hwnd = hwnd;
    ti.hinst = NULL;
    ti.uId = 0;
    ti.lpszText = tooltip;
    ti.rect.left = rect.left;    
    ti.rect.top = rect.top;
    ti.rect.right = rect.right;
    ti.rect.bottom = rect.bottom;

    SendMessage(hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);	
} 		
In our example, we set a tooltip for the main window.

INITCOMMONCONTROLSEX iccex;
...
iccex.dwICC = ICC_WIN95_CLASSES;
iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
InitCommonControlsEx(&iccex);
A tooltip is a part of common controls, therefore, we must initialize common controls.

Creation of a tooltip consists of several steps. We must create a tooltip window. Then we make it a topmost window, so that it is not covered by another window. We create a tooltip text and TOOLTIPINFO structure. The structure must be filled with important info. The window handle, tooltip text and the rectangle, which will our tooltip cover. In our example, our tooltip will cover the whole client area of a window.

SendMessage(hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
The tooltip is really added to the window, after we send the TTM_ADDTOOL message.

Tooltip control
Figure: Tooltip control
Updown control

Updown control, also known as a spin control, combines a pair of buttons displayed as arrows with a buddy edit control. Clicking the arrows increments or decrements the value in the edit control. The Updown control is created with the UPDOWN_CLASSW window class.

updown.c
#include <windows.h>
#include <commctrl.h>
#include <strsafe.h>

#define ID_UPDOWN 1
#define ID_EDIT 2
#define ID_STATIC 3
#define UD_MAX_POS 30
#define UD_MIN_POS 0

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateControls(HWND);

HWND hUpDown, hEdit, hStatic;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Updown control";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Updown control",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        100, 100, 280, 200, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {

        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    LPNMUPDOWN lpnmud;
    UINT code;

    switch(msg) {

        case WM_CREATE:

            CreateControls(hwnd);

            break;

        case WM_NOTIFY:

            code = ((LPNMHDR) lParam)->code;

            if (code == UDN_DELTAPOS) {

                lpnmud = (NMUPDOWN *) lParam;                

                int value = lpnmud->iPos + lpnmud->iDelta;

                if (value < UD_MIN_POS) {
                    value = UD_MIN_POS;
                }

                if (value > UD_MAX_POS) {
                    value = UD_MAX_POS;
                }

                const int asize = 4;
                wchar_t buf[asize];
                size_t cbDest = asize * sizeof(wchar_t);
                StringCbPrintfW(buf, cbDest, L"%d", value);

                SetWindowTextW(hStatic, buf);                  
            }

            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CreateControls(HWND hwnd) {

    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_UPDOWN_CLASS;
    InitCommonControlsEx(&icex); 

    hUpDown = CreateWindowW(UPDOWN_CLASSW, NULL, WS_CHILD | WS_VISIBLE 
        | UDS_SETBUDDYINT | UDS_ALIGNRIGHT, 
        0, 0, 0, 0, hwnd, (HMENU) ID_UPDOWN, NULL, NULL);

    hEdit = CreateWindowExW(WS_EX_CLIENTEDGE, WC_EDITW, NULL, WS_CHILD 
        | WS_VISIBLE | ES_RIGHT, 15, 15, 70, 25, hwnd, 
        (HMENU) ID_EDIT, NULL, NULL);
    
    hStatic = CreateWindowW(WC_STATICW, L"0", WS_CHILD | WS_VISIBLE
        | SS_LEFT, 15, 60, 300, 230, hwnd, (HMENU) ID_STATIC, NULL, NULL);

    SendMessageW(hUpDown, UDM_SETBUDDY, (WPARAM) hEdit, 0);
    SendMessageW(hUpDown, UDM_SETRANGE, 0, MAKELPARAM(UD_MAX_POS, UD_MIN_POS));
    SendMessageW(hUpDown, UDM_SETPOS32, 0, 0);
}
In the code example, we have an UpDown control and a static text control. The currently selected value of the UpDown is displayed in the static text control.

#define UD_MAX_POS 30
#define UD_MIN_POS 0
These two constants are used for maximum and minimum values of the UpDown control.

hUpDown = CreateWindowW(UPDOWN_CLASSW, NULL, WS_CHILD | WS_VISIBLE 
    | UDS_SETBUDDYINT | UDS_ALIGNRIGHT, 
    0, 0, 0, 0, hwnd, (HMENU) ID_UPDOWN, g_hInst, NULL);
To create an UpDown control, we pass the UPDOWN_CLASSW to the CreateWindowW() function. The UDS_SETBUDDYINT flag causes the UpDown control to send a message (WM_SETTEXT) to its buddy when its position changes. The UDS_ALIGNRIGHT flag positions the UpDown control next to the right edge of its buddy window.

SendMessageW(hUpDown, UDM_SETBUDDY, (WPARAM) hEdit, 0);
The UDM_SETBUDDY message sets the Edit control to be the buddy window for the UpDown control.

SendMessageW(hUpDown, UDM_SETRANGE, 0, MAKELPARAM(UD_MAX_POS, UD_MIN_POS));
The UDM_SETRANGE message sets the minimum and maximum positions for the UpDown control.

SendMessageW(hUpDown, UDM_SETPOS32, 0, 0);
With the UDM_SETPOS32 message, we set the initial position of the UpDown control.

code = ((LPNMHDR) lParam)->code;

if (code == UDN_DELTAPOS) {
...
}
The UDN_DELTAPOS notification is sent by the operating system to the parent window of the UpDown control when the position of the control is about to change (i.e. before the control updates its value).

lpnmud = (NMUPDOWN *) lParam;

int value = lpnmud->iPos + lpnmud->iDelta;
The NMUPDOWN structure contains information about the UpDown's modification. The iPos value is the UpDown control's current position. The iDelta is the proposed change in the UpDown control's position. From these two values, we compute the final value that will appear in the control.

if (value < UD_MIN_POS) {
    value = UD_MIN_POS;
}

if (value > UD_MAX_POS) {
    value = UD_MAX_POS;
}
This code ensures that the static text does not display values outside the UpDown's range.

int const asize = 4;
wchar_t buf[asize];
size_t cbDest = asize * sizeof(wchar_t);
StringCbPrintfW(buf, cbDest, L"%d", value);
Using the StringCbPrintfW() function, we build the string to be displayed in the static text control.

SetWindowTextW(hStatic, buf);
Finally, the static text control is updated with the SetWindowTextW() function.

UpDown control
Figure: UpDown control
Month Calendar Control

A Month Calendar is a complex control which is used to select a date. The date can be selected in a simple and intuitive way.

monthcalendar.c
#include <windows.h>
#include <commctrl.h>
#include <wchar.h>
#include <strsafe.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateControls(HWND);
void GetSelectedDate(HWND, HWND);

HWND hStat;
HWND hMonthCal;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
  LPSTR lpCmdLine, int nCmdShow) {
  
    HWND hwnd;
    MSG  msg;
    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Month Calendar";
    wc.hInstance     = hInstance ;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc ;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);

    hwnd = CreateWindowW(wc.lpszClassName, L"Month Calendar",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        100, 100, 250, 300, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    LPNMHDR lpNmHdr;

    switch(msg) {

        case WM_CREATE:

            CreateControls(hwnd);
            break;

        case WM_NOTIFY:

            lpNmHdr = (LPNMHDR) lParam;

            if (lpNmHdr->code == MCN_SELECT) {
                GetSelectedDate(hMonthCal, hStat);
            }
 	  
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            break; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CreateControls(HWND hwnd) {

    hStat = CreateWindowW(WC_STATICW, L"", 
        WS_CHILD | WS_VISIBLE, 80, 240, 80, 30,
        hwnd, (HMENU)1, NULL, NULL);

    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(icex);
    icex.dwICC  = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icex);

    hMonthCal = CreateWindowW(MONTHCAL_CLASSW, L"", 
        WS_BORDER | WS_CHILD | WS_VISIBLE | MCS_NOTODAYCIRCLE,  
        20, 20, 200, 200, hwnd, (HMENU)2, NULL, NULL);
}

void GetSelectedDate(HWND hMonthCal, HWND hStat) {

    SYSTEMTIME time;
    const int dsize = 20;
    wchar_t buf[dsize];

    ZeroMemory(&time, sizeof(SYSTEMTIME));
    SendMessage(hMonthCal, MCM_GETCURSEL, 0, (LPARAM) &time);
  
    size_t cbDest = dsize * sizeof(wchar_t);
    StringCbPrintfW(buf, cbDest, L"%d-%d-%d", 
          time.wYear, time.wMonth, time.wDay);

    SetWindowTextW(hStat, buf);
}
In our example, we have two controls: a month calendar control and a static text. The selected date from the month calendar control is displayed in the static text.

hMonthCal = CreateWindowW(MONTHCAL_CLASSW, L"", 
    WS_BORDER | WS_CHILD | WS_VISIBLE | MCS_NOTODAYCIRCLE,  
    20, 20, 200, 200, hwnd, (HMENU)2, NULL, NULL);
Here we create a month calendar control. The class name to create a month calendar control is MONTHCAL_CLASSW. If we use the MCS_NOTODAYCIRCLE window style, the today's date is not circled.

INITCOMMONCONTROLSEX icex;

icex.dwSize = sizeof(icex);
icex.dwICC  = ICC_DATE_CLASSES;
InitCommonControlsEx(&icex);
To register a month calendar control, we specify the ICC_DATE_CLASSES flag for the dwICC member of the INITCOMMONCONTROLSEX structure.

case WM_NOTIFY:

    lpNmHdr = (LPNMHDR) lParam;

    if (lpNmHdr->code == MCN_SELECT) {
        GetSelectedDate(hMonthCal, hStat);
    }

    break;
If an event occurs in the month calendar control, the WM_NOTIFY message is sent. The lParam contains a pointer to an NMHDR structure that contains the notification code and additional information.

SendMessage(hMonthCal, MCM_GETCURSEL, 0, (LPARAM) &time);
To fill the structure with the selected date, we send a MCM_GETCURSEL message to the calendar control.

size_t cbDest = dsize * sizeof(wchar_t);
StringCbPrintfW(buf, cbDest, L"%d-%d-%d", 
      time.wYear, time.wMonth, time.wDay);

SetWindowTextW(hStat, buf);
We build the string and set the date to the static text control.

Month Calendar
Figure: Month Calendar
In this part of the Windows API tutorial, we have continued covering Windows controls — a trackbar, a tooltip, an up-down, and a month calendar.

;; ------------------------

Windows API controls III

In this chapter, we will finish talking about Windows API controls. We will mention radio buttons, radio box, combo box, and a progress bar.


 
Radio buttons and GroupBox

Here we introduce two controls. A group box is a rectangle that surrounds a set of controls. These are often radio buttons. A group box has a label that describes the control. The purpose of this control is to group controls that are somehow related. A radio button is a special kind of button that can be selected by the user, but not cleared. It allows the user to select a single exclusive choice from a group of options.

radio_buttons.c
#include <windows.h>

#define ID_BLUE 1
#define ID_YELLOW 2
#define ID_ORANGE 3

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

HINSTANCE g_hinst;
COLORREF g_color;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    HWND hwnd;
    MSG  msg ;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"GroupBox";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    g_hinst = hInstance;
  
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"GroupBox",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 300, 170, 0, 0, hInstance, 0);  


    while (GetMessage(&msg, NULL, 0, 0)) {
            
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    HDC hdc;
    PAINTSTRUCT ps;
    HBRUSH hBrush, holdBrush;
    HPEN hPen, holdPen;

    switch(msg) {

        case WM_CREATE:

            CreateWindowW(L"Button", L"Choose colour", 
                  WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
                  10, 10, 120, 110, hwnd, (HMENU) 0, g_hinst, NULL);
            CreateWindowW(L"Button", L"Blue",
                  WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON,
                  20, 30, 100, 30, hwnd, (HMENU) ID_BLUE , g_hinst, NULL);
            CreateWindowW(L"Button", L"Yellow",
                  WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON,
                  20, 55, 100, 30, hwnd, (HMENU) ID_YELLOW , g_hinst, NULL);
            CreateWindowW(L"Button", L"Orange",
                  WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON,
                  20, 80, 100, 30, hwnd, (HMENU) ID_ORANGE , g_hinst, NULL);      
            break;

        case WM_COMMAND:

            if (HIWORD(wParam) == BN_CLICKED) {
            
                switch (LOWORD(wParam)) {
                
                    case ID_BLUE:
                        g_color = RGB(0, 76, 255);
                        break;
                    case ID_YELLOW:
                        g_color = RGB(255, 255, 0);
                        break;
                    case ID_ORANGE:
                        g_color = RGB(255, 123, 0);
                        break;
                }                    
                InvalidateRect(hwnd, NULL, TRUE);
            }
            break;

        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);
            hBrush = CreateSolidBrush(g_color);
            hPen = CreatePen(PS_NULL, 1, RGB(0, 0, 0));
            holdPen = SelectObject(hdc, hPen);
            holdBrush = (HBRUSH) SelectObject(hdc, hBrush);

            Rectangle(hdc, 160, 20, 260, 120);

            SelectObject(hdc, holdBrush);
            SelectObject(hdc, holdPen);
            DeleteObject(hPen);
            DeleteObject(hBrush);
            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example, we have a group box with three radio buttons. By clicking on the radio button, we select a background colour for the rectangle on the right.

CreateWindowW(L"Button", L"Choose colour", 
        WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
        10, 10, 120, 110, hwnd, (HMENU) 0, g_hinst, NULL);
A group box is a special kind of a button created with the BS_GROUPBOX style.

CreateWindowW(L"Button", L"Blue",
        WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON,
        20, 30, 100, 30, hwnd, (HMENU) ID_BLUE , g_hinst, NULL);
A radio button is also a special kind of a button with BS_AUTORADIOBUTTON style.

case ID_BLUE:
    g_color = RGB(0, 76, 255);
    break;
If we click on the radio button, a global variable is filled with selected colour. This variable is used to create a brush that fills the rectangle.

InvalidateRect(hwnd, NULL, TRUE);
We invalidate the rectangle (in this case whole window), which will cause the client area to be redrawn. This will launch a WM_PAINT message. During the WM_PAINT message, we draw the rectangle. Drawing is explained in GDI chapter in more detail.

Radio buttons in a GroupBox
Figure: Radio buttons in a GroupBox
Combo box

A combo box is a combination of an edit box or static text and a list. A combo box is used when we need to select an item from a list of available options.

combobox.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

HINSTANCE g_hinst;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    HWND hwnd;
    MSG  msg ;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Application";
    wc.hInstance     = hInstance ;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc ;
    wc.hCursor       = LoadCursor(0,IDC_ARROW);

    g_hinst = hInstance;
  
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"Combo box",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 270, 170, 0, 0, hInstance, 0);  


    while (GetMessage(&msg, NULL, 0, 0)) {
    
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
        WPARAM wParam, LPARAM lParam) {

    static HWND hwndCombo, hwndStatic;
    const wchar_t *items[] = { L"FreeBSD", L"OpenBSD", 
        L"NetBSD", L"Solaris", L"Arch" };

    switch(msg) {
    
        case WM_CREATE:
        
              hwndCombo = CreateWindowW(L"Combobox", NULL, 
                    WS_CHILD | WS_VISIBLE | CBS_DROPDOWN,
                    10, 10, 120, 110, hwnd, NULL, g_hinst, NULL);   

              CreateWindowW(L"Button", L"Drop down", 
                    WS_CHILD | WS_VISIBLE,
                    150, 10, 90, 25, hwnd, (HMENU) 1, g_hinst, NULL); 

              hwndStatic = CreateWindowW(L"Static", L"", 
                    WS_CHILD | WS_VISIBLE,
                    150, 80, 90, 25, hwnd, NULL, g_hinst, NULL); 

              for (int i = 0; i < 4; i++ ) {
              
                  SendMessageW(hwndCombo, CB_ADDSTRING, 0, (LPARAM) items[i]);
              }

              break;

        case WM_COMMAND:
        
             if (HIWORD(wParam) == BN_CLICKED) {
             
                  SendMessage(hwndCombo, CB_SHOWDROPDOWN, (WPARAM) TRUE, 0);
             }
             
             if (HIWORD(wParam) == CBN_SELCHANGE) {      
             
                  LRESULT sel = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
                  SetWindowTextW(hwndStatic, items[sel]);
             }
             break;

        case WM_DESTROY:
        
            PostQuitMessage(0);
            break; 
    }
  
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example, we put three controls on the window: a combo box, a button, and a static text. The static text displays the currently selected item from the combo box. It is used to demonstrate the CBN_SELCHANGE combo box message. The button programatically opens the combo box.

hwndCombo = CreateWindowW(L"Combobox", NULL, 
    WS_CHILD | WS_VISIBLE | CBS_DROPDOWN,
    10, 10, 120, 110, hwnd, NULL, g_hinst, NULL); 
To create a combo box, we use the L"Combobox" window class. The CBS_DROPDOWN flag creates a drop-down list.

for (int i = 0; i < 4; i++ ) {

    SendMessageW(hwndCombo, CB_ADDSTRING, 0, (LPARAM) items[i]);
}
We fill the combo box with items. To add a string to the combo box, we send a CB_ADDSTRING message.

if (HIWORD(wParam) == BN_CLICKED) {

    SendMessage(hwndCombo, CB_SHOWDROPDOWN, (WPARAM) TRUE, 0);
}
Clicking on the button causes a CB_SHOWDROPDOWN message to be send, which programmatically invokes a drop down of the combo box.

If we select an item from the combo box, the window procedure receives the WM_COMMAND message with the notification message CBN_SELCHANGE in the high-order word of the wParam parameter.

if (HIWORD(wParam) == CBN_SELCHANGE) {      

    LRESULT sel = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    SetWindowTextW(hwndStatic, items[sel]);
}
We figure out the currently selected item. We send a CB_GETCURSEL message to the combo box. The function returns the index of the currently selected item. We set the static text to the currently selected string.

Combo box
Figure: Combo box
Progress bar

A progress bar is a control that is used when we process lengthy tasks. It is animated so that the user knows that our task is progressing.

progressbar.c
#include <windows.h>
#include <commctrl.h>

#define ID_BUTTON 1
#define ID_TIMER 2

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateControls(HWND);

HWND hwndPrgBar;
HWND hbtn;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PWSTR lpCmdLine, int nCmdShow) {

    HWND hwnd;
    MSG  msg ;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Application";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);
    hwnd = CreateWindowW(wc.lpszClassName, L"Progress bar",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100, 100, 260, 170, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
        WPARAM wParam, LPARAM lParam) {

    static int i = 0;
 
    switch(msg) {

        case WM_CREATE:

            CreateControls(hwnd);
            break;

        case WM_TIMER:

            SendMessage(hwndPrgBar, PBM_STEPIT, 0, 0);
            i++;

            if (i == 150) {

                KillTimer(hwnd, ID_TIMER);
                SendMessageW(hbtn, WM_SETTEXT, (WPARAM) NULL, (LPARAM) L"Start");
                i = 0;
            }

            break;
              
        case WM_COMMAND:
          
            if (i == 0) {  

                i = 1;
                SendMessage(hwndPrgBar, PBM_SETPOS, 0, 0);
                SetTimer(hwnd, ID_TIMER, 5, NULL);
                SendMessageW(hbtn, WM_SETTEXT, (WPARAM) NULL, (LPARAM) L"In progress");
            }

          break;

        case WM_DESTROY:

            KillTimer(hwnd, ID_TIMER);
            PostQuitMessage(0);
            break; 
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void CreateControls(HWND hwnd) {

    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_PROGRESS_CLASS;
    InitCommonControlsEx(&icex);

    hwndPrgBar = CreateWindowEx(0, PROGRESS_CLASS, NULL, 
          WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
          30, 20, 190, 25, hwnd, NULL, NULL, NULL);   

    hbtn = CreateWindowW(L"Button", L"Start", 
          WS_CHILD | WS_VISIBLE,
          85, 90, 85, 25, hwnd, (HMENU) 1, NULL, NULL);  

    SendMessage(hwndPrgBar, PBM_SETRANGE, 0, MAKELPARAM(0, 150));
    SendMessage(hwndPrgBar, PBM_SETSTEP, 1, 0);
}
In our example, we have a progress bar and a button. The button starts a timer which updates the progress bar.

hwndPrgBar = CreateWindowEx(0, PROGRESS_CLASS, NULL, 
      WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
      30, 20, 190, 25, hwnd, NULL, NULL, NULL);  
We create a progress bar control with PROGRESS_CLASS class name and PBS_SMOOTH style.

SendMessage(hwndPrgBar, PBM_SETRANGE, 0, MAKELPARAM(0, 150));
SendMessage(hwndPrgBar, PBM_SETSTEP, 1, 0);
We set the range of the progress bar and its step.

i = 1;
SendMessage(hwndPrgBar, PBM_SETPOS, 0, 0);
SetTimer(hwnd, ID_TIMER, 5, NULL);
When we press the Start button, we set the i value to 1, set the initial position of the progress bar, and start the timer. The timer will periodically send a WM_TIMER message to the window procedure, until it is killed.

SendMessageW(hbtn, WM_SETTEXT, (WPARAM) NULL, (LPARAM) L"In progress"); 
When the timer is in progress, we change the label of the button.

case WM_TIMER:

    SendMessage(hwndPrgBar, PBM_STEPIT, 0, 0);
    i++;

    if (i == 150) {

        KillTimer(hwnd, ID_TIMER);
        SendMessageW(hbtn, WM_SETTEXT, (WPARAM) NULL, (LPARAM) L"Start");
        i = 0;
    }

    break;
When we receive the WM_TIMER message, we update the progress bar by one step sending the PBM_STEPIT message. The timer is killed when the i variable reaches the upper limit of the progress bar.

Progress bar
Figure: Progress bar
In this part of the Windows API tutorial, we have finished covering Windows controls.

;; -----------------------------

Advanced controls in Windows API

In this section of the Windows API tutorial, we will talk more about two advanced Windows controls: a tab control and a list box control.


 
Tab control

A tab control joins multiple windows with corresponding tabs.

tabcontrol.c
#include <windows.h>
#include <commctrl.h>
#include <wchar.h>

#define ID_TABCTRL 1
#define ID_EDIT 2
#define BTN_ADD 3
#define BTN_DEL 4
#define BTN_CLR 5
#define MAX_TAB_LEN 15

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
HWND hTab, hEdit;

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    PWSTR pCmdLine, int nCmdShow) {

    MSG  msg ;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"Tab control";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Tab control",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 380, 230, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
  
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    TCITEMW tie;
    wchar_t text[4];
    LRESULT count, id;
    INITCOMMONCONTROLSEX icex;

    switch(msg) {

        case WM_CREATE:
       
            icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            icex.dwICC = ICC_TAB_CLASSES;
            InitCommonControlsEx(&icex);

            hTab = CreateWindowW(WC_TABCONTROLW, NULL, WS_CHILD | WS_VISIBLE,
                0, 0, 200, 150, hwnd,(HMENU) ID_TABCTRL, NULL, NULL);

            hEdit = CreateWindowW(WC_EDITW, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER,
                250, 20, 100, 25, hwnd, (HMENU) ID_EDIT, NULL, NULL);

            SendMessage(hEdit, EM_SETLIMITTEXT, MAX_TAB_LEN, 0);
  
            CreateWindowW(WC_BUTTONW, L"Add", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                250, 50, 100, 25, hwnd, (HMENU) BTN_ADD, NULL, NULL);

            CreateWindowW(WC_BUTTONW, L"Delete", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                250, 80, 100, 25, hwnd, (HMENU) BTN_DEL, NULL, NULL);

            CreateWindowW(WC_BUTTONW, L"Clear", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                250, 110, 100, 25, hwnd, (HMENU) BTN_CLR, NULL, NULL);
            break;

        case WM_COMMAND:

            switch(LOWORD(wParam)) {

                case BTN_ADD:

                    GetWindowTextW(hEdit, text, 250);

                    if (lstrlenW(text) != 0 ) {

                        tie.mask = TCIF_TEXT;
                        tie.pszText = text;
                        count = SendMessageW(hTab, TCM_GETITEMCOUNT, 0, 0);
                        SendMessageW(hTab, TCM_INSERTITEMW, count, 
                            (LPARAM) (LPTCITEM) &tie);
                    }
                    break;

                case BTN_DEL:
                
                    id = SendMessageW(hTab, TCM_GETCURSEL, 0, 0);
                    
                    if (id != -1) {
                    
                       SendMessageW(hTab, TCM_DELETEITEM, 0, id);
                    }
                    break;

                case BTN_CLR:
               
                    SendMessageW(hTab, TCM_DELETEALLITEMS, 0, 0);
                    break;
            } 
            break;

        case WM_DESTROY:
        
            PostQuitMessage(0);
            break;
    }
   
    return(DefWindowProcW(hwnd, msg, wParam, lParam));
}
In our example, we use one tab control, one edit control, and three buttons. We will dynamically create and delete tabs on the tab control.

hTab = CreateWindowW(WC_TABCONTROLW, NULL, WS_CHILD | WS_VISIBLE,
    0, 0, 200, 150, hwnd,(HMENU) ID_TABCTRL, NULL, NULL);
We use the WC_TABCONTROL window class to create a tab control.

hEdit = CreateWindowW(WC_EDITW, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER,
    250, 20, 100, 25, hwnd, (HMENU) ID_EDIT, NULL, NULL);

SendMessage(hEdit, EM_SETLIMITTEXT, MAX_TAB_LEN, 0);
We create an edit control and sets its maximum size with the EM_SETLIMITTEXT message.

if (lstrlenW(text) != 0 ) {

    tie.mask = TCIF_TEXT;
    tie.pszText = text;
    count = SendMessageW(hTab, TCM_GETITEMCOUNT, 0, 0);
    SendMessageW(hTab, TCM_INSERTITEMW, count, 
       (LPARAM) (LPTCITEM) &tie);
}
To add a new tab, we fill the TCITEMW structure. We provide the type of data to be set (in our case TCIF_TEXT) and the actual text. Then we send two messages. The TCM_GETITEMCOUNT message gets the number of tabs. It will be used in the second message. The TCM_INSERTITEMW message inserts a new tab in the control, using the count variable and the TCITEMW structure.

id = SendMessageW(hTab, TCM_GETCURSEL, 0, 0);

if (id != -1) {

   SendMessageW(hTab, TCM_DELETEITEM, 0, id);
}
To delete an specific tab, we need the currently selected tab. We figure it out by sending the TCM_GETCURSEL message to the tab control. To delete the tab, we send the TCM_DELETEITEM message, specifying the item to be deleted in the wParam parameter.

SendMessageW(hTab, TCM_DELETEALLITEMS, 0, 0);
To delete all tabs from the tab control, we send the TCM_DELETEALLITEMS message.

Tab control
Figure: Tab control
List Box

A List Box contains a simple list from which the user can generally select one or more items. Selected items are marked.

listbox.c
#include <windows.h>
#include <commctrl.h>
#include <strsafe.h>

#define IDC_LIST 1
#define IDC_STATIC 2

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

typedef struct {
 
    wchar_t name[30]; 
    wchar_t job[20]; 
    int age; 

} Friends; 

Friends friends[] = {
 
    {L"Lucy", L"waitress", 18}, 
    {L"Thomas", L"programmer", 25}, 
    {L"George", L"police officer", 26}, 
    {L"Michael", L"producer", 38}, 
    {L"Jane", L"steward", 28}, 
}; 

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    PWSTR pCmdLine, int nCmdShow) {

    MSG  msg ;    
    WNDCLASSW wc = {0};
    wc.lpszClassName = L"MyListBox";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);
  
    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"List Box",
                  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                  100, 100, 340, 200, 0, 0, hInstance, 0);  

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return (int) msg.wParam;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {

    static HWND hwndList, hwndStatic;
    wchar_t buf[128];

    switch(msg) {

        case WM_CREATE:
       
            hwndList = CreateWindowW(WC_LISTBOXW , NULL, WS_CHILD 
                | WS_VISIBLE | LBS_NOTIFY, 10, 10, 150, 120, hwnd, 
                (HMENU) IDC_LIST, NULL, NULL);

            hwndStatic = CreateWindowW(WC_STATICW , NULL, WS_CHILD | WS_VISIBLE,
               200, 10, 120, 45, hwnd, (HMENU) IDC_STATIC, NULL, NULL);

            for (int i = 0; i < ARRAYSIZE(friends); i++)  { 
                 SendMessageW(hwndList, LB_ADDSTRING, 0, (LPARAM) friends[i].name);
            } 

            break;
 
        case WM_COMMAND:
        
            if (LOWORD(wParam) == IDC_LIST) {        
                if (HIWORD(wParam) == LBN_SELCHANGE) {                   
                    int sel = (int) SendMessageW(hwndList, LB_GETCURSEL, 0, 0);
                    StringCbPrintfW(buf, ARRAYSIZE(buf), L"Job: %ls\nAge: %d", 
                        friends[sel].job, friends[sel].age);
                    SetWindowTextW(hwndStatic, buf);
               }
            }            
            
            break;

        case WM_DESTROY:
        
            PostQuitMessage(0);
            break;
    }

    return (DefWindowProcW(hwnd, msg, wParam, lParam));
}
In this example, we display a list box control and a static text control. By selecting a person from a list box, we display his job and age in the static control.

hwndList = CreateWindowW(WC_LISTBOXW , NULL, WS_CHILD 
        | WS_VISIBLE | LBS_NOTIFY, 10, 10, 150, 120, hwnd, 
        (HMENU) IDC_LIST, g_hinst, NULL);
The WC_LISTBOXW window class is used to create a list box control. The LBS_NOTIFY flag causes the list box to send a notification code to the parent window whenever the user clicks a list box item (LBN_SELCHANGE) , double-clicks an item (LBN_DBLCLK), or cancels the selection (LBN_SELCANCEL).

for (int i = 0; i < ARRAYSIZE(friends); i++)  { 
    SendMessageW(hwndList, LB_ADDSTRING, 0, (LPARAM) friends[i].name);
} 
The list box is filled with data by sending multiple LB_ADDSTRING messages.

if (HIWORD(wParam) == LBN_SELCHANGE) {                   
        int sel = (int) SendMessageW(hwndList, LB_GETCURSEL, 0, 0);
        StringCbPrintfW(buf, ARRAYSIZE(buf), L"Job: %ls\nAge: %d", 
                friends[sel].job, friends[sel].age);
        SetWindowTextW(hwndStatic, buf);
}
If we select an item from a list box, the window procedure receives a LBN_SELCHANGE message. First, we determine the currently selected item by sending a LB_GETCURSEL message to the list box. Then we copy the job name and age from the friends structure to the buf array. Finally, we set the static text with SetWindowTextW() function call.

list box
Figure: List Box
In this part of the Windows API tutorial, we have covered two more advanced Windows controls.

;; ------------------------------

Custom controls in Windows API

Here we will demonstrate, how to create our own custom controls. Windows API has a collection of various prebuilt controls. More specific controls have to be created manually. We use the GDI to create custom controls.


 
The Burning control

This control can be found in various media burning applications, like Nero Burning ROM.

#include <windows.h>
#include <commctrl.h>
#include <wchar.h>


LRESULT CALLBACK PanelProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);


HINSTANCE g_hinst;
LRESULT g_pos = 150;


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                    PWSTR lpCmdLine, int nCmdShow)
{
  HWND hwnd;
  MSG  msg;    
  WNDCLASSW wc = {0};

  wc.lpszClassName = L"Application";
  wc.hInstance     = hInstance;
  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
  wc.lpfnWndProc   = WndProc;
  wc.hCursor       = LoadCursor(0, IDC_ARROW);

  g_hinst = hInstance;
  
  RegisterClassW(&wc);
  hwnd = CreateWindowW(wc.lpszClassName, L"Burning control",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN,
                100, 100, 400, 250, 0, 0, hInstance, 0);  

  while( GetMessage(&msg, NULL, 0, 0)) {
    DispatchMessage(&msg);
  }

  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam)
{

  static HWND hwndTrack, hwndBurn;
  WNDCLASSW rwc = {0};
 
  INITCOMMONCONTROLSEX InitCtrlEx;

  InitCtrlEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
  InitCtrlEx.dwICC  = ICC_BAR_CLASSES;
  InitCommonControlsEx(&InitCtrlEx);

  switch(msg)  
  {
      case WM_CREATE:
               
          rwc.lpszClassName = L"BurningControl";

          rwc.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);
          rwc.style         = CS_HREDRAW;
          rwc.lpfnWndProc   = PanelProc;
          rwc.hCursor       = LoadCursor(0, IDC_ARROW);
          RegisterClassW(&rwc);

          hwndBurn = CreateWindowExW(WS_EX_STATICEDGE , L"BurningControl", NULL,
              WS_CHILD | WS_VISIBLE, 0, 330, 490, 30, hwnd, (HMENU)1, NULL, NULL);

          hwndTrack = CreateWindowExW(0, TRACKBAR_CLASSW, NULL,
              WS_CHILD | WS_VISIBLE | TBS_FIXEDLENGTH | TBS_NOTICKS,
              40, 25, 150, 25, hwnd, (HMENU) 2, g_hinst, NULL);

          SendMessage(hwndTrack, TBM_SETRANGE,  TRUE,  MAKELONG(0, 750));
          SendMessage(hwndTrack, TBM_SETPAGESIZE, 0,  20); 
          SendMessage(hwndTrack, TBM_SETTICFREQ, 20, 0); 
          SendMessage(hwndTrack, TBM_SETPOS, TRUE, 150);  
          break;

      case WM_SIZE:

          SetWindowPos(hwndBurn, NULL, 0, HIWORD(lParam)-30, 
              LOWORD(lParam), 30, SWP_NOZORDER);
          break;

      case WM_HSCROLL:

          g_pos = SendMessage(hwndTrack, TBM_GETPOS, 0, 0);
          InvalidateRect(hwndBurn, NULL, TRUE);
          break;            

      case WM_DESTROY:

          PostQuitMessage(0);
          break; 
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}


LRESULT CALLBACK PanelProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam)
{
  HBRUSH hBrushYellow, hBrushRed, holdBrush;
  HPEN hPen, holdPen;
  HFONT hFont, holdFont;
  PAINTSTRUCT ps;
  RECT rect, rect2;
  
  wchar_t *cap[] = { L"75", L"150", L"225", L"300", L"375", L"450", 
      L"525", L"600", L"675"};

  HDC hdc;
  int till;
  int step, full;
  int i;

  switch(msg)  
  {
    case WM_PAINT:
    
        hdc = BeginPaint(hwnd, &ps);

        GetClientRect(hwnd, &rect);

        till = (rect.right / 750.0) * g_pos;
        step = rect.right / 10.0;
        full = (rect.right / 750.0) * 700;
        
        hBrushYellow = CreateSolidBrush(RGB(255, 255, 184));
        hBrushRed = CreateSolidBrush(RGB(255, 110, 110));

        hPen = CreatePen(PS_NULL, 1, RGB(0, 0, 0));
        holdPen = SelectObject(hdc, hPen);

        hFont = CreateFontW(13, 0, 0, 0, FW_MEDIUM, 0, 0, 0, 0, 
                0, 0, 0, 0, L"Tahoma");

        holdFont = SelectObject(hdc, hFont);
        
        if(till > full) {
        
            SelectObject(hdc, hBrushYellow);
            Rectangle(hdc, 0, 0, full, 30);
            holdBrush = SelectObject(hdc, hBrushRed);
            Rectangle(hdc, full, 0, till, 30);

        } else {
        
            holdBrush = SelectObject(hdc, hBrushYellow);
            Rectangle(hdc, 0, 0, till, 30);
        }

        SelectObject(hdc, holdPen);

        for ( i = 1; i < 10; i++) {

          MoveToEx(hdc, i*step, 0, NULL);
          LineTo(hdc, i*step, 7);

          rect2.bottom = 28;
          rect2.top = 8;
          rect2.left = i*step-10;
          rect2.right = i*step+10;

          SetBkMode(hdc, TRANSPARENT) ;
          DrawTextW(hdc, cap[i-1], wcslen(cap[i-1]), &rect2, DT_CENTER);
        }

        SelectObject(hdc, holdBrush);
        DeleteObject(hBrushYellow);
        DeleteObject(hBrushRed);

        DeleteObject(hPen);

        SelectObject(hdc, holdFont);
        DeleteObject(hFont);
                    
        EndPaint(hwnd, &ps);
        break;
  }

  return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example, we display a trackbar control and our custom burning control. The trackbar control is used to control the state of the burning control.

The burning control is a simple window. It is placed on the bottom of the parent window. It is completely drawn during the WM_PAINT message. The lines, text, and background is drawn using the GDI function calls.

Burning control
Figure: Burning control
In this part of the Windows API tutorial, we have created a Burning custom control.

;; ----------------------

The GDI in Windows API

Graphics Device Interface (GDI) is an interface for working with graphics. It is used to interact with graphic devices such as monitors, printers or files. The GDI allows programmers to display data on a screen or printer without having to be concerned about the details of a particular device. The GDI insulates the programmer from the hardware. From the programmer's point of view, the GDI is a group of API functions for working with graphics. The GDI consists of 2D Vector Graphics, Fonts and Images. To begin drawing graphics, we must obtain a device context (DC) object.


 
The WM_PAINT message is generated whenever a window needs to be redrawn. The programmer draws on the client area of the window; the surrounding frame, including the title bar, is automatically painted by the operating system.

HDC BeginPaint(HWND hwnd, LPPAINTSTRUCT lpPaint);
The BeginPaint() function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting. It returns a handle to the device context. A device context is an object through which we perform the painting operations.

BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
Each painting operations is ended with EndPaint(). This function is required for each call to the BeginPaint() function, but only after the painting is complete.

Pixel

Pixel is the smallest element of an image that can be individually processed in a video display system. The SetPixel() is a function that draws a single pixel on the window.

COLORREF SetPixel(HDC hdc, int x, int y, COLORREF crColor);
The function's first parameter is a handle to the device context. The next two parameters are the x and y coordinates of the point. The last parameter is the color to be used to paint the point. If the function succeeds, the return value is the RGB value that the function sets the pixel to.

pixels.c
#include <windows.h>
#include <time.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void DrawPixels(HWND hwnd);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Pixels";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Pixels",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100, 100, 300, 250, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    srand(time(NULL));

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {

    switch(msg) {

        case WM_PAINT:

            DrawPixels(hwnd);
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void DrawPixels(HWND hwnd) {

    PAINTSTRUCT ps;
    RECT r;

    GetClientRect(hwnd, &r);

    if (r.bottom == 0) {
    
        return;
    }

    HDC hdc = BeginPaint(hwnd, &ps);

    for (int i=0; i<1000; i++) {

        int x = rand() % r.right;
        int y = rand() % r.bottom;
        SetPixel(hdc, x, y, RGB(255, 0, 0));
    }

    EndPaint(hwnd, &ps);
}
In our example we display randomly 1000 red pixels on the client area of the window.

wc.style = CS_HREDRAW | CS_VREDRAW;
These two flags cause the window to be redrawn when it is resized.

srand(time(NULL));
The srand() function seeds the random number generator.

case WM_PAINT:

    DrawPixels(hwnd);
    break;
Drawing is performed in a reaction to the WM_PAINT message. The actual drawing is delegated to the DrawPixels() function.

HDC hdc = BeginPaint(hwnd, &ps);
The BeginPaint() function prepares the specified window for painting. It fills a PAINTSTRUCT structure with information about the painting. It returns a handle to a display device context for the specified window.

GetClientRect(hwnd, &r);
We retrieve the coordinates of the window's client area. We randomly draw on the window and we need to know where we can draw at the moment.

for (int i=0; i<1000; i++) {

    int x = rand() % r.right;
    int y = rand() % r.bottom;
    SetPixel(hdc, x, y, RGB(255, 0, 0));
}
One thousand points are randomly drawn on the window. The SetPixel() function draws a pixel at a specified location using the chosen colour.

EndPaint(hwnd, &ps);
At the end of the painting we call the EndPaint() functions. The function releases the display device context that BeginPaint() retrieved.

Pixels
Figure: Pixels
Line

A line is a basic graphics primitive. It is drawn with two functions: MoveToEx() and LineTo().

BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lpPoint);
The MoveToEx() function updates the current position to the specified point and optionally returns the previous position.

BOOL LineTo(HDC hdc, int nXEnd, int nYEnd);
The LineTo() function draws a line from the current position up to, but not including, the specified point.

lines.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Lines";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Lines",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 300, 200, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    HDC hdc;
    PAINTSTRUCT ps;

    switch(msg) {
    
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);

            MoveToEx(hdc, 50, 50, NULL);
            LineTo(hdc, 250, 50);

            HPEN hWhitePen = GetStockObject(WHITE_PEN);
            HPEN hOldPen = SelectObject(hdc, hWhitePen);

            MoveToEx(hdc, 50, 100, NULL);
            LineTo(hdc, 250, 100);

            SelectObject(hdc, hOldPen);

            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:
 
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
The example draws two lines; one in black color and one in white color.

MoveToEx(hdc, 50, 50, NULL);
LineTo(hdc, 250, 50);
A line is drawn between points (50, 50) and (250, 50). The default BLACK_PEN is used.

HPEN hWhitePen = GetStockObject(WHITE_PEN);
The GetStockObject() function retrieves a handle to the built-in white pen which is specified with the WHITE_PEN value. It is not necessary (but it is not harmful) to delete stock objects by calling DeleteObject().

HPEN hOldPen = SelectObject(hdc, hWhitePen);
The SelectObject() function selects an object into the specified device context (DC). The new object replaces the previous object of the same type.

SelectObject(hdc, hOldPen);
We revert back to the old BLACK_PEN pen.

Lines
Figure: Lines
Rectangle

To draw a rectangle, we use the Rectangle() function.

BOOL Rectangle(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, 
    int nBottomRect);
The first parameter of the function is the handle to the device context. The next two parameters are the x and y coordinates of the upper-left corner of the rectangle. The last two parameters are the x, y coordinates of the lower-right corner of the rectangle. If the function fails, the return value is zero. If it succeeds, the return value is non-zero.

rectangle.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Rectangle";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Rectangle",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 250, 200, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    HDC hdc;
    PAINTSTRUCT ps;

    switch(msg) {
    
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);
            Rectangle(hdc, 50, 50, 200, 100);
            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:
 
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
The outline of the rectangle is drawn using the current pen. The background is drawn using the current brush.

Rectangle(hdc, 50, 50, 200, 100);
The rectangle is drawn using the Rectangle() function. We draw the rectangle using two points: top-left point and bottom-right point.

Rectangle
Figure: Rectangle
Bézier curve

Bézier curves are curved lines defined by mathematical formulas. The mathematical method for drawing curves was created by Pierre Bézier in the late 1960's for the manufacturing of automobiles at Renault.

BOOL PolyBezier(HDC hdc, const POINT *lppt, DWORD cPoints);
The function's first parameter is a handle to the device context. The second parameter is a pointer to an array of POINT structures that contain the endpoints and control points of the curve(s).

beziercurve.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"BezierCurve";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Beziér curve",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 500, 200, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    HDC hdc;
    PAINTSTRUCT ps;

    POINT points[4] = { 20, 40, 320, 200, 330, 110, 450, 40 };

    switch(msg) {
    
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);

            PolyBezier(hdc, points, 4);

            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:
 
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In the example, we draw a curved line with the PolyBezier() function.

POINT points[4] = { 20, 40, 320, 200, 330, 110, 450, 40 };
These points form a Bézier curve. The first point is a starting point. The next two points are control points. The last point is an ending point of the curve.

PolyBezier(hdc, points, 4);
The PolyBezier() function draws the curved line.

Bézier curve
Figure: Bézier curve
Pen

A pen is an elementary graphics object. It is used to draw lines, curves and outlines of rectangles, ellipses, polygons, or other shapes.

There are two types of pen: cosmetic and geometric. Cosmetic pens are simple pens with a fixed width of 1. They have three attributes: width, style, and color. They are more efficient than geometric pens. Cosmetic pens can be created with the CreatePen(), CreatePenIndirect(), or ExtCreatePen() functions.

Geometric pens are more complex than cosmetic pens. They have seven attributes: width, style, color, pattern, hatch, end cap, and join style. Geometric pes are created with the ExtCreatePen() function.

HPEN CreatePen(int fnPenStyle, int nWidth, COLORREF crColor);
The CreatePen() function creates a logical pen with a specified style, width, and colour.

HPEN ExtCreatePen(DWORD dwPenStyle, DWORD dwWidth, const LOGBRUSH *lplb, 
    DWORD dwStyleCount, const DWORD *lpStyle);
The ExtCreatePen() function creates a logical cosmetic or geometric pen. The first parameter is a combination of type, style, end cap, and join attributes. The second parameter is the width of the pen. The third parameter is a pointer to the LOGBRUSH structure. The structure defines the style, color, and pattern of a physical brush. The fourth parameter is the length, in DWORD units, of the lpStyle array. This value must be zero if dwPenStyle is not PS_USERSTYLE. The style count is limited to 16. The last parameter is a pointer to an array. The first value specifies the length of the first dash in a user-defined style, the second value specifies the length of the first space, and so on. This pointer must be NULL if dwPenStyle is not S_USERSTYLE.

After a pen has been created, we select it into the application's device context with the SelectObject() function. From this point on, the application uses this pen for any line-drawing operations in its client area.

Pen styles

A pen style is a particular pattern applied on a line object. There are predefined pen styles such as PS_SOLID, PS_DASH, PS_DOT, or PS_DASHDOT. It is also possible to create custom pen styles.

penstyles.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void DrawLines(HWND);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Pen styles";
    wc.hInstance     = hInstance;
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Pen styles",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 350, 180, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
        case WM_PAINT:

            DrawLines(hwnd);
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void DrawLines(HWND hwnd) {

    PAINTSTRUCT ps;

    HDC hdc = BeginPaint(hwnd, &ps);
    HPEN hPen1 = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
    HPEN hPen2 = CreatePen(PS_DASH, 1, RGB(0, 0, 0));
    HPEN hPen3 = CreatePen(PS_DOT, 1, RGB(0, 0, 0));
    HPEN hPen4 = CreatePen(PS_DASHDOT, 1, RGB(0, 0, 0));
    HPEN hPen5 = CreatePen(PS_DASHDOTDOT, 1, RGB(0, 0, 0));

    HPEN holdPen = SelectObject(hdc, hPen1);
    MoveToEx(hdc, 50, 30, NULL);
    LineTo(hdc, 300, 30);

    SelectObject(hdc, hPen2);
    MoveToEx(hdc, 50, 50, NULL);
    LineTo(hdc, 300, 50);

    SelectObject(hdc, hPen2);
    MoveToEx(hdc, 50, 70, NULL);
    LineTo(hdc, 300, 70);

    SelectObject(hdc, hPen3);
    MoveToEx(hdc, 50, 90, NULL);
    LineTo(hdc, 300, 90);

    SelectObject(hdc, hPen4);
    MoveToEx(hdc, 50, 110, NULL);
    LineTo(hdc, 300, 110);

    SelectObject(hdc, holdPen);
    DeleteObject(hPen1);
    DeleteObject(hPen2);
    DeleteObject(hPen3);
    DeleteObject(hPen4);
    DeleteObject(hPen5);

    EndPaint(hwnd, &ps);  
}
In our example, we draw five different lines using five different pen styles.

case WM_PAINT:

    DrawLines(hwnd);
    break;
The actual drawing is delegated to the DrawLines() function.

HPEN hPen1 = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
The CreatePen() function creates a logical pen with a specified style, width and colour. The PS_SOLID stands for a solid pen. We use the RGB macro to generate a colour for the pen.

SelectObject(hdc, hPen1);
To activate a pen, we call the SelectObject() function.

MoveToEx(hdc, 50, 30, NULL);
LineTo(hdc, 300, 30);
To draw lines, we use the MoveToEx() and the LineTo() functions.

DeleteObject(hPen1);
DeleteObject(hPen2);
DeleteObject(hPen3);
DeleteObject(hPen4);
DeleteObject(hPen5);
In the end, we clean up resources.

Pen styles
Figure: Pen styles
Line joins

The lines can be joined using three different join styles: PS_JOIN_BEVEL, PS_JOIN_MITEl, and PS_JOIN_ROUND.

linejoins.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void DoDrawing(HWND);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Pens";
    wc.hInstance     = hInstance;
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Line joins",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 450, 200, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
        case WM_PAINT:

            DoDrawing(hwnd);
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void DoDrawing(HWND hwnd) {

    LOGBRUSH brush;
    COLORREF col = RGB(0, 0, 0);
    DWORD pen_style = PS_SOLID | PS_JOIN_MITER | PS_GEOMETRIC;

    brush.lbStyle = BS_SOLID;
    brush.lbColor = col;
    brush.lbHatch = 0;       

    PAINTSTRUCT ps;

    HDC hdc = BeginPaint(hwnd, &ps);

    HPEN hPen1 = ExtCreatePen(pen_style, 8, &brush, 0, NULL);
    HPEN holdPen = SelectObject(hdc, hPen1);
    
    POINT points[5] = { { 30, 30 }, { 130, 30 }, { 130, 100 }, 
        { 30, 100 }, { 30, 30}};
    Polygon(hdc, points, 5);
    
    pen_style = PS_SOLID | PS_GEOMETRIC | PS_JOIN_BEVEL;
    HPEN hPen2 = ExtCreatePen(pen_style, 8, &brush, 0, NULL);  

    SelectObject(hdc, hPen2);
    DeleteObject(hPen1);

    POINT points2[5] = { { 160, 30 }, { 260, 30 }, { 260, 100 }, 
        { 160, 100 }, {160, 30 }};
    MoveToEx(hdc, 130, 30, NULL);
    Polygon(hdc, points2, 5);

    pen_style = PS_SOLID | PS_GEOMETRIC | PS_JOIN_ROUND;
    HPEN hPen3 = ExtCreatePen(pen_style, 8, &brush, 0, NULL);  

    SelectObject(hdc, hPen3);
    DeleteObject(hPen2);

    POINT points3[5] = { { 290, 30 }, { 390, 30 }, { 390, 100 }, 
        { 290, 100 }, {290, 30 }};
    MoveToEx(hdc, 260, 30, NULL);
    Polygon(hdc, points3, 5);

    SelectObject(hdc, holdPen);
    DeleteObject(hPen3);
      
    EndPaint(hwnd, &ps);  
}
In the example, we show three types of line joins on rectangular shapes.

pen_style = PS_SOLID | PS_GEOMETRIC | PS_JOIN_BEVEL;
HPEN hPen2 = ExtCreatePen(pen_style, 8, &brush, 0, NULL); 
The ExtCreatePen() function creates a solid, geometric pen with the PS_JOIN_BEVEL join.

POINT points2[5] = { { 160, 30 }, { 260, 30 }, { 260, 100 }, 
    { 160, 100 }, {160, 30 }};
MoveToEx(hdc, 130, 30, NULL);
Polygon(hdc, points2, 5);
From the provided points, we create a rectangular shape with the Polygon() function.

Line joins
Figure: Line joins
Brush

A brush is an elementary graphics object. It is used to paint the background of graphics shapes, such as rectangles, ellipses, or polygons. A brush can be a solid colour, a hatch, or a custom bitmap pattern.

Solid brush

A solid brush is a color. It is created with the CreateSolidBrush() function.

HBRUSH CreateSolidBrush(COLORREF crColor);
The CreateSolidBrush() function creates a brush with the specified solid color.

solidbrush.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void DrawRectangles(HWND);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Brush";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Solid Brush",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 220, 240, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

  return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
        case WM_PAINT:

            DrawRectangles(hwnd);	    
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void DrawRectangles(HWND hwnd) {

    PAINTSTRUCT ps;

    HDC hdc = BeginPaint(hwnd, &ps);
    HPEN hPen = CreatePen(PS_NULL, 1, RGB(0, 0, 0));
    HPEN holdPen = SelectObject(hdc, hPen);

    HBRUSH hBrush1 = CreateSolidBrush(RGB(121, 90, 0));
    HBRUSH hBrush2 = CreateSolidBrush(RGB(240, 63, 19));
    HBRUSH hBrush3 = CreateSolidBrush(RGB(240, 210, 18));
    HBRUSH hBrush4 = CreateSolidBrush(RGB(9, 189, 21));

    HBRUSH holdBrush = SelectObject(hdc, hBrush1);

    Rectangle(hdc, 30, 30, 100, 100);
    SelectObject(hdc, hBrush2);
    Rectangle(hdc, 110, 30, 180, 100);
    SelectObject(hdc, hBrush3);
    Rectangle(hdc, 30, 110, 100, 180);
    SelectObject(hdc, hBrush4);
    Rectangle(hdc, 110, 110, 180, 180);

    SelectObject(hdc, holdPen);
    SelectObject(hdc, holdBrush);

    DeleteObject(hPen);
    DeleteObject(hBrush1);
    DeleteObject(hBrush2);
    DeleteObject(hBrush3);
    DeleteObject(hBrush4);

    EndPaint(hwnd, &ps);
}
In the example, we create 4 rectangles filled with 4 different solid colours.

HBRUSH hBrush1 = CreateSolidBrush(RGB(121, 90, 0));
Here we create a solid colour brush.

HBRUSH holdBrush = SelectObject(hdc, hBrush1);
A new brush is selected into the device context.

Solid brushes
Figure: Solid brushes
Hatch brush

There are six predefined hatch brushes available. In our example, we show all of them.

HBRUSH CreateHatchBrush(int fnStyle, COLORREF clrref);
The CreateHatchBrush() function creates a brush that has the specified hatch pattern and color.

hatchbrushes.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void DrawRectangles(HWND hwnd);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_VREDRAW | CS_HREDRAW;
    wc.lpszClassName = L"Brush";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Hatch brushes",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 300, 220, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    switch(msg) {
  
      case WM_PAINT:

          DrawRectangles(hwnd);
          break;

      case WM_DESTROY:

          PostQuitMessage(0);
          return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void DrawRectangles(HWND hwnd) {

    PAINTSTRUCT ps;

    HDC hdc = BeginPaint(hwnd, &ps);
    HPEN hPen = CreatePen(PS_NULL, 1, RGB(0, 0, 0));
    HPEN holdPen = SelectObject(hdc, hPen);

    HBRUSH hBrush1 = CreateHatchBrush(HS_BDIAGONAL, RGB(0, 0, 0));
    HBRUSH hBrush2 = CreateHatchBrush(HS_FDIAGONAL, RGB(0, 0, 0));
    HBRUSH hBrush3 = CreateHatchBrush(HS_CROSS, RGB(0, 0, 0));
    HBRUSH hBrush4 = CreateHatchBrush(HS_HORIZONTAL, RGB(0, 0, 0));
    HBRUSH hBrush5 = CreateHatchBrush(HS_DIAGCROSS, RGB(0, 0, 0));
    HBRUSH hBrush6 = CreateHatchBrush(HS_VERTICAL, RGB(0, 0, 0));

    HBRUSH holdBrush = SelectObject(hdc, hBrush1);

    DWORD col = GetSysColor(COLOR_BTNFACE);
    SetBkColor(hdc, col);

    Rectangle(hdc, 30, 30, 100, 80);
    SelectObject(hdc, hBrush2);
    Rectangle(hdc, 110, 30, 180, 80);
    SelectObject(hdc, hBrush3);
    Rectangle(hdc, 190, 30, 260, 80);
    SelectObject(hdc, hBrush4);
    Rectangle(hdc, 30, 110, 100, 160);
    SelectObject(hdc, hBrush5);
    Rectangle(hdc, 110, 110, 180, 160);
    SelectObject(hdc, hBrush6);
    Rectangle(hdc, 190, 110, 260, 160);

    SelectObject(hdc, holdPen);
    SelectObject(hdc, holdBrush);

    DeleteObject(hPen);
    DeleteObject(hBrush1);
    DeleteObject(hBrush2);
    DeleteObject(hBrush3);
    DeleteObject(hBrush4);
    DeleteObject(hBrush5);
    DeleteObject(hBrush6);

    EndPaint(hwnd, &ps);
}
This example is very similar to the previous one. We only use a new function call CreateHatchBrush().

HBRUSH hBrush1 = CreateHatchBrush(HS_BDIAGONAL, RGB(0, 0, 0));
A diagonal hatch brush is created.

HBRUSH holdBrush = SelectObject(hdc, hBrush1);
The brush is selected into the device context. A handle to the old brush is returned.

DeleteObject(hBrush1);
The brush object is deleted.

Hatch brushes
Figure: Hatch brushes
Custom brush

A custom brush can be created with the CreatePatternBrush() function.

HBRUSH CreatePatternBrush(HBITMAP hbmp);
The function takes a handle to the bitmap to be used to create the brush.

custombrush.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Custom brush";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Custom brush",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 300, 200, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    HDC hdc;
    PAINTSTRUCT ps;
    static HBITMAP hBtm;

    UINT bits[8] = { 0x111111ff, 0xffffffff, 0xffffffff, 0xffffffff,
        0x00000000, 0x00000000, 0x00000000, 0x00000000 };

    switch(msg) {

        case WM_CREATE:

            hBtm = CreateBitmap(8, 8, 1, 1, (LPBYTE) bits);

            break;
    
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);
            
            HBRUSH hCustomBrush = CreatePatternBrush(hBtm);
            HBRUSH hOldBrush = SelectObject(hdc, hCustomBrush);

            SelectObject(hdc, GetStockObject(NULL_PEN));

            Rectangle(hdc, 20, 20, 250, 160);

            SelectObject(hdc, hOldBrush);
            DeleteObject(hCustomBrush);

            SelectObject(hdc, GetStockObject(BLACK_PEN));

            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:
 
            DeleteObject(hBtm);
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
The example paints a rectangle; its interior is filled with a custom brush pattern.

hBtm = CreateBitmap(8, 8, 1, 1, (LPBYTE) bits);
We create a bitmap pattern with the CreateBitmap() function.

HBRUSH hCustomBrush = CreatePatternBrush(hBtm);
The CreatePatternBrush() function creates a brush object from the provided bitmap.

HBRUSH hOldBrush = SelectObject(hdc, hCustomBrush);
We select the custom brush with the SelectObject() function.

SelectObject(hdc, GetStockObject(NULL_PEN));
We will not draw the outline of the rectangle. No outline is drawn when we select the NULL_PEN.

Rectangle(hdc, 20, 20, 250, 160);
The rectangle is painted with the Rectangle() function; its interior is painted with the selected custom brush.

Custom brush
Figure: Custom brush
Shapes

Shapes are more sophisticated geometrical objects. We will draw various geometrical shapes in the following example.

shapes.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Shapes";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Shapes",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 390, 230, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
    
    HDC hdc;
    PAINTSTRUCT ps;
    const POINT polygon[10] = { 30, 145, 85, 165, 105, 
        110, 65, 125, 30, 105 };

    switch(msg) {
  
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);
 
            Ellipse(hdc, 30, 30, 120, 90);
            RoundRect(hdc, 150, 30, 240, 90, 15, 20);
            Chord(hdc, 270, 30, 360, 90, 270, 45, 360, 45);
            Polygon(hdc, polygon, 5);
            Rectangle(hdc, 150, 110, 230, 160);

            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
In our example, we have created an ellipse, a rounded rectangle, a chord, a polygon, and a rectangle.

Ellipse(hdc, 30, 30, 120, 90);
The Ellipse() function draws an ellipse. The parameters of Ellipse() are the x and y coordinates of the upper-left and bottom-right corner of a bounding rectangle. The ellipse is drawn within this rectangle.

RoundRect(hdc, 150, 30, 240, 90, 15, 20);
The RoundRect() function draws a rectangle with rounded corners. The parameters of RoundRect() are the x and y coordinates of the upper-left and bottom-right corner of a bounding rectangle. The last two parameters are the width and height of the ellipse used to draw the rounded corners.

Chord(hdc, 270, 30, 360, 90, 270, 45, 360, 45);
The Chord() function draws a chord. A chord is a a region bounded by the intersection of an ellipse and a line segment. The first four parameters are the x and y coordinates of the top-left corner and x and y coordinates of the bottom-right corner of the bounding rectangle. The next four parameters are the x and y coordinates of the radial defining the beginning of the chord and x and y coordinates of the radial defining the end of the chord.

Polygon(hdc, polygon, 5);
The Polygon() function draws a polygon consisting of two or more vertices connected by straight lines. The polygon is a pointer to an array of POINT structures that specify the vertices of the polygon. The last parameter is the number of points in the array.

Rectangle(hdc, 150, 110, 230, 160);
The Rectangle() function draws a rectangle. The parameters of the function are the x and y coordinates of the upper-left and lower-right corner of the rectangle.

Shapes
Figure: Shapes
Star

In the following example, we draw a star shape with the Polyline() function.

BOOL Polyline(HDC hdc, const POINT *lppt, int cPoints);
The Polyline() function draws a series of line segments by connecting the points in the specified array. The function's first parameter is a handle to a device context. The second parameter is a pointer to an array of POINT structures. The third parameter is the number of points in the array. This number must be greater than or equal to two.

star.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Star";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Star",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 300, 250, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {
    
    HDC hdc;
    PAINTSTRUCT ps;

    POINT points[11] = { 
        { 10, 85 }, 
        { 85, 75 }, 
        { 110, 10 }, 
        { 135, 75 }, 
        { 210, 85 },
        { 160, 125 }, 
        { 170, 190 },
        { 110, 150 }, 
        { 50, 190 },
        { 60, 125 },
        { 10, 85 } 
    };

    switch(msg) {
    
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);
            Polyline(hdc, points, 11);
            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:
 
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
The example draws a star object.

POINT points[11] = { 
    { 10, 85 }, 
    { 85, 75 }, 
    { 110, 10 }, 
    { 135, 75 }, 
    { 210, 85 },
    { 160, 125 }, 
    { 170, 190 },
    { 110, 150 }, 
    { 50, 190 },
    { 60, 125 },
    { 10, 85 } 
};
This is an array of POINTS of the star.

Polyline(hdc, points, 11);
The Polyline() function draws the star shape.

Star
Figure: Star
Text

The TextOutW() function writes a character string at the specified location, using the currently selected font, background colour, and text colour.

BOOL TextOut(HDC hdc, int nXStart, int nYStart, LPCTSTR lpString, int cchString);
The function's first parameter is a handle to the device context. The next two parameters are the x and y coordinates of the reference point that the system uses to align the string. The third parameter is a pointer to the string to be drawn. The last parameter is the length of the string.

sonnet55.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {
    
    MSG  msg ;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Sonnet 55";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Sonnet 55",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 390, 350, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
    
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
  WPARAM wParam, LPARAM lParam) {
  
    HDC hdc;
    PAINTSTRUCT ps;

    DWORD color;

    HFONT hFont, holdFont;

    static wchar_t *ver1 = L"Not marble, nor the gilded monuments";
    static wchar_t *ver2 = L"Of princes, shall outlive this powerful rhyme;";
    static wchar_t *ver3 = L"But you shall shine more bright in these contents";
    static wchar_t *ver4 = L"Than unswept stone, besmear'd with sluttish time.";
    static wchar_t *ver5 = L"When wasteful war shall statues overturn,";
    static wchar_t *ver6 = L"And broils root out the work of masonry,";
    static wchar_t *ver7 = L"Nor Mars his sword, nor war's quick fire shall burn";
    static wchar_t *ver8 = L"The living record of your memory.";
    static wchar_t *ver9 = L"'Gainst death, and all oblivious enmity";
    static wchar_t *ver10 = L"Shall you pace forth; your praise shall still find room";
    static wchar_t *ver11 = L"Even in the eyes of all posterity";
    static wchar_t *ver12 = L"That wear this world out to the ending doom.";
    static wchar_t *ver13 = L"So, till the judgment that yourself arise,";
    static wchar_t *ver14 = L"You live in this, and dwell in lovers' eyes.";

    switch(msg) {
    
        case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);

            color = GetSysColor(COLOR_BTNFACE);
            SetBkColor(hdc, color);

            hFont = CreateFontW(15, 0, 0, 0, FW_MEDIUM, 0, 0, 0, 0,
                                0, 0, 0, 0, L"Georgia");
            holdFont = SelectObject(hdc, hFont);

            TextOutW(hdc, 50, 20,  ver1,  lstrlenW(ver1));
            TextOutW(hdc, 50, 40,  ver2,  lstrlenW(ver2));
            TextOutW(hdc, 50, 60,  ver3,  lstrlenW(ver3));
            TextOutW(hdc, 50, 80,  ver4,  lstrlenW(ver4));
            TextOutW(hdc, 50, 100, ver5,  lstrlenW(ver5));
            TextOutW(hdc, 50, 120, ver6,  lstrlenW(ver6));
            TextOutW(hdc, 50, 140, ver7,  lstrlenW(ver7));
            TextOutW(hdc, 50, 160, ver8,  lstrlenW(ver8));
            TextOutW(hdc, 50, 180, ver9,  lstrlenW(ver9));
            TextOutW(hdc, 50, 200, ver10, lstrlenW(ver10));
            TextOutW(hdc, 50, 220, ver11, lstrlenW(ver11));
            TextOutW(hdc, 50, 240, ver12, lstrlenW(ver12));
            TextOutW(hdc, 50, 260, ver13, lstrlenW(ver13));
            TextOutW(hdc, 50, 280, ver14, lstrlenW(ver14));

            SelectObject(hdc, holdFont);
            DeleteObject(hFont);

            EndPaint(hwnd, &ps);
            break;

        case WM_DESTROY:

            PostQuitMessage(0);
           return 0;
    }
  
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
We draw a few verses on the window with the TextOutW() function.

color = GetSysColor(COLOR_BTNFACE);
SetBkColor(hdc, color);
By default, if we draw some text on the client area of the window, the background is set to white color. We can change this by setting the background color using the SetBkColor() function. We used the typical Windows gray color. The GetSysColor() function is used to get the system colors used in buttons, title, or the backround of window controls.

hFont = CreateFontW(15, 0, 0, 0, FW_MEDIUM, 0, 0, 0, 0,
                    0, 0, 0, 0, L"Georgia");
holdFont = SelectObject(hdc, hFont);
Here we create a font object with the CreateFontW() function. The function has 14 parameters; we do not have to specify all of them. We specify only the font size, font weight, and the fontface parameters.

TextOutW(hdc, 50, 20, verse1, lstrlenW(verse1));
The text is drawn onto the window using the TextOutW() function. The length of the string is determined with the lstrlenW() function.

Text
Figure: Text
Drawing a bitmap

A bitmap is a graphical object used to create, manipulate, and store images as files on a disk. BMP is the native bitmap format of Windows and is used to store virtually any type of bitmap data.

drawbitmap.c
#include <windows.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {

    MSG  msg;
    WNDCLASSW wc = {0};

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = L"Draw Bitmap";
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(0, IDC_ARROW);

    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Draw Bitmap",
          WS_OVERLAPPEDWINDOW | WS_VISIBLE,
          100, 100, 280, 220, NULL, NULL, hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0)) {
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int) msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {

    static HBITMAP hBitmap;
    HDC hdc;
    PAINTSTRUCT ps;
    BITMAP bitmap;
    HDC hdcMem;
    HGDIOBJ oldBitmap;

    switch(msg) {

        case WM_CREATE:
     
             hBitmap = (HBITMAP) LoadImageW(NULL, L"C:\\prog\\slovakia.bmp", 
                        IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

             if (hBitmap == NULL) {
                 MessageBoxW(hwnd, L"Failed to load image", L"Error", MB_OK); 
             }

             break;      

        case WM_PAINT:
        
             hdc = BeginPaint(hwnd, &ps);

             hdcMem = CreateCompatibleDC(hdc);
             oldBitmap = SelectObject(hdcMem, hBitmap);

             GetObject(hBitmap, sizeof(bitmap), &bitmap);
             BitBlt(hdc, 5, 5, bitmap.bmWidth, bitmap.bmHeight, 
                 hdcMem, 0, 0, SRCCOPY);

             SelectObject(hdcMem, oldBitmap);
             DeleteDC(hdcMem);

             EndPaint(hwnd, &ps);

             break;

        case WM_DESTROY:

            DeleteObject(hBitmap);
            PostQuitMessage(0);
            
            return 0;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
The example draws the national flag of Slovakia on the window. The picture is in the BMP file format.

static HBITMAP hBitmap;
HBITMAP is a handle to a bitmap object.

BITMAP bitmap;
The BITMAP structure defines the type, width, height, color format, and bit values of a bitmap.

hBitmap = (HBITMAP) LoadImageW(NULL, L"C:\\prog\\slovakia.bmp", 
        IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
The LoadImageW() function loads a BMP image from the disk. It returns a handle to the bitmap.

GetObject(hBitmap, sizeof(bitmap), &bitmap);
The GetObject() function stores information about the bitmap in the provided BITMAP structure.

hdcMem = CreateCompatibleDC(hdc);
The CreateCompatibleDC() function creates a memory device context compatible with the application's current screen.

oldBitmap = SelectObject(hdcMem, hBitmap);
The SelectObject() function selects an object into the memory device context. A bitmap must be selected into the memory device context before it may be used for anything.

BitBlt(hdc, 5, 5, bitmap.bmWidth, bitmap.bmHeight, hdcMem, 0, 0, SRCCOPY);
The BitBlt() function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.

SelectObject(hdcMem, oldBitmap);
An application should always replace a new object with the original, default object after it has finished drawing with the new object.

DeleteDC(hdcMem);
The resources associated with the memory device context are released.

Drawing a bitmap
Figure: Drawing a bitmap
In this part of the Windows API tutorial, we did some drawing.

;; --------------------

